% Created 2021-09-15 Wed 06:51
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Holy Frege}
\date{\today}
\title{Emacs From Scratch Configuration}
\hypersetup{
 pdfauthor={Holy Frege},
 pdftitle={Emacs From Scratch Configuration},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\section*{Start!}
\label{sec:org4b9c3bd}
기본적인 것을 설정한다. emacs.org는 .emac.d폴더에 넣어 둔다. 그리고 수정할때 마다, 추가할 때 마다 tangle에 의해서 자동으로 init.el이 만들어진다.
\begin{itemize}
\item \texttt{[ evaluation ]}
\item eval-buffer
\end{itemize}
buffer 전체를 해석한다.
\begin{itemize}
\item C-x e
\end{itemize}
한문장을 해석한다.
\begin{itemize}
\item M-:
\end{itemize}
minibuffer에서 해석한다.  현재의 mode에서 실행할 수 있는 장점이 있다.
\begin{itemize}
\item ns-command-modifier: command키를 meta로 한다.
\item make-backup-files:  backup file을 만들지 않는다.
\begin{itemize}
\item server socket directory: emacs --daemon=a라고 하면 a라는  server socket file이 해당 폴더에 저장된다.
\end{itemize}
\end{itemize}
\begin{itemize}
\item (server-start)
emacs를 실행시키면 server가 된다. frame을 닫으면 server도 stop된다. 즉 emacs화면을 유지한 상태에서 emacsclient의 접속을 받아 server의 기능을 유지한다. 우리는 화면(frame)을 닫아도 background에서 도는 daemon을 원하기 때문에 이 방법은 쓸 수 없다.
\item emacs --daemon
emacs의 configuration을 실행한 후 daemon이 된다. background에서 계속 돈다.
\begin{itemize}
\item emacs --daemon=one\_daemon
emacs daemon에 이름을 줘서 여러개의 daemon을 만들 수 있다.
\end{itemize}

\item\relax [문제]
emacs --daemon으로 실행할 때 init.el을 실행한다. 그리고 daemon으로 동작한다. 이때 emacsclient -c로 새로운 frame을 만들고 접속할때, 이상한 frame이 만들어진다. font나 modeline이 이상하게 보여진다. 이것은 처음 만들어진 frame에서만 발생되는 현상이다. 그 이후에 frame을 만들면 정상적으로 보인다. 이것은 emacsclient -c가 first frame을 만들때 font나 modeline의 설정을 init.el에 있는것이 아닌 default값을 쓰기 때문이다. 즉 emacs daemon이 실행하면서 설정한 값들이 emacsclient -c로  실행될 때 init.el에 기술된 설정을 적용하지 않는것이다.
\item\relax [해결법]
daemon이 init.el을 적용할때 hook을 걸어두는 것이다. frame이 만들어진 이후에 font나 modeline을 설정하게 만드는 함수를 만들고 hook을 걸어둔다. deamon이 hook을 실행하고,모든 설정을 수행한 후에 deamon을 돌고 emacsclient -c로 연결을 하면, frame이 만들어지는데 이때 hook이 실행되는 원리다. 약간 설명이 미흡한데 자세한 동작원리를 모르기 때문이다.

\item initial-frame-alist, default-frame-alist
frame 설정에 관련된 값들이 key,value쌍으로 저장된다. 최초의 frame관련 설정은 initial-frame-alist에 있고, default는 그 이후 만들어지는 frame에 대한 설정을 가지고 있다.

\item\relax [emacs server 사용법]
emacs --fd-daemon은 emacs daemon을 동작시킨다. daemon은 socket file을 가지고 있는데, 그 위치를 emacs.org설정파일에 /tmp/emacs1000/server라는 이름으로 기술되어 있다. emacsclient는 daemon에 접속하기 위해서 emacsclient -c --server-socket-name=/tmp/emacs1000/server를 기술해야만 접속이 가능하다.
\end{itemize}

\begin{verbatim}
(server-start)
(require 'cl-lib)
(require 'org-protocol)

(setq ns-command-modifier 'meta)
(fset 'yes-or-no-p 'y-or-n-p)
(setq make-backup-files nil)
;; (setq server-socket-dir "/tmp/emacs1000")
(defvar holy/default-font-size 220)
(defvar holy/default-variable-font-size 220)
\end{verbatim}

\section*{Package System Setup}
\label{sec:orgbca82b6}

\subsection*{default package settings}
\label{sec:org445790f}
emacs의 package관리 시스템은 old-school인 package가 있고, modern한 use-package가 있다. use-package로 package를 관리한다. 
\begin{itemize}
\item package-archive
package repo를 지정한다.
\item package-archive-contents
\end{itemize}
package repo마다 가지고 있는 package 목록과 설치여부를 표시한 list
\begin{itemize}
\item package-initialize
\end{itemize}
package-archive-contents에 installed로 표시된 package를 설치하고 load(autoload지시자가 있는 function을 실행)한다.
\begin{itemize}
\item package-refresh-contents
\end{itemize}
package-archive-content를 update한다.
\begin{itemize}
\item use-package-always-ensure
\end{itemize}
use-package는 package를 install, load, config할 수 있는데, install을 할때 ensure:t를 해주면 package가 system에 없을 경우 down받아서 install해준다. use-package를 사용하는 모든 경우에 system설치 여부를 확인하고 없으면 install하겠다는 function이다.
\begin{verbatim}

;; Initialize package sources
(require 'package)

(setq package-archives '(("melpa" . "https://melpa.org/packages/")
			 ("org" . "https://orgmode.org/elpa/")
			 ("elpa" . "https://elpa.gnu.org/packages/")))

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

  ;; Initialize use-package on non-Linux platforms
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)

\end{verbatim}
\subsection*{automatically update packages}
\label{sec:org46e3f57}
\begin{itemize}
\item upgrade, update
\end{itemize}
설치된 package를 update하려면, M-x list-package를 통해 repo에서 새로운 package content list를 다운받아서 비교를 통해서 update항목을 알려준다. U를 눌러 update를 하고 x를 눌러 실행한다. 매번 list-package로 update 유무를 판단하는것은 힘들다. 자동으로 하는 설정이다.
7일, 오전 9시에 update를 하고 하기전에 prompt로 물어보게 했다.
\texttt{NOTE}
package update는 잘못된 package를 update를 할경우 설정이 꼬일 수 있다. 그래서 안사용해도 된다.
\begin{verbatim}

(use-package auto-package-update
   :custom
   (auto-package-update-interval 7)
   (auto-package-update-prompt-before-update t)
   (auto-package-update-hide-results t)
   :config
   (auto-package-update-maybe)
   (auto-package-update-at-time "09:00"))
\end{verbatim}
\section*{Basic UI Configuration}
\label{sec:org045b668}
\begin{itemize}
\item fringe-mode
보여지는 화면의 좌우 여백(padding)을 준다고 생각하면 된다.
\item do-list
\end{itemize}
do-list는 python의 for 변수 in 배열 구문으로 보면된다.
4가지 mode에는 line number를 disable하겠다는 뜻이다.
\begin{verbatim}

(setq inhibit-startup-message t)

(scroll-bar-mode -1)        ; Disable visible scrollbar
(tool-bar-mode -1)          ; Disable the toolbar
(tooltip-mode -1)           ; Disable tooltips
(set-fringe-mode 10)        ; Give some breathing room

(menu-bar-mode -1)            ; Disable the menu bar

;; Set up the visible bell
(setq visible-bell t)

(column-number-mode)
(global-display-line-numbers-mode t)

;; Disable line numbers for some modes
(dolist (mode '(org-mode-hook
		term-mode-hook
		shell-mode-hook
		eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

\end{verbatim}
\subsection*{mark 영역 color설정}
\label{sec:orgb0be25a}
\begin{itemize}
\item mark 영역의 색을 변경한다.
\begin{verbatim}
(set-face-attribute 'region nil :background "#834")
\end{verbatim}
\end{itemize}
\subsection*{Font Configuration}
\label{sec:org9d3278c}
\begin{itemize}
\item system에 설치되어야 하는 font는 2가지다. fixed-pitch-font(fira code;
for coding), variable-pitch-font(문서작성용) 아래에서 다운받는다.
\end{itemize}
\href{https://github.com/tonsky/FiraCode}{Fira Code} ,\href{https://fonts.google.com/specimen/Cantarell}{Cantarell} 
\begin{itemize}
\item 아래 설정에 3개의 이름의 face가 설정되어
있다. default,fixed-pitch,variable-pitch 이런 이름으로 선언만
한것이다. mode에 진입하면, mode의 구성요소별로 해당 face를 선택할 수
있다. face가 없는것은 default란 이름의 face가 적용되기 때문에
대부분의 mode에서는 fira code retina 폰트로 설정될
것이다. variable-pitch-mode에서는 variable-pitch를 face로 사용하기
때문에 Cantarell로 보일 것이다.
\begin{itemize}
\item modeline과 dired모드에서 한자가 나오고 icon이 깨지는 것은 M-x all-the-icons-install-fonts를 안해줘서 그렇다.
\end{itemize}
\end{itemize}
\begin{verbatim}

 (defun holy/set-font-faces ()		
   (message "Setting faces!")
   ;; (set-face-attribute 'default nil :font "Fira Code" :height holy/default-font-size)
      (set-face-attribute 'default nil :font "Fira Code"  :height 180)
   ;; (set-face-attribute 'default nil :font "Fira Code Retina-14" :height holy/default-font-size)

       ;; Set the fixed pitch face
   ;; (set-face-attribute 'fixed-pitch nil :font "Fira Code" :height holy/default-font-size) 
   (set-face-attribute 'fixed-pitch nil :font "Fira Code"  :height 180)
       ;; Set the variable pitch face
   ;; (set-face-attribute 'variable-pitch nil :font "Cantarell" :height holy/default-font-size :weight 'regular)
      (set-face-attribute 'variable-pitch nil :font "Cantarell"  :height 180)
)

(if (daemonp)
    (add-hook 'after-make-frame-functions
       (lambda (frame)
	       (setq doom-modeline-icon t)
	   (with-selected-frame frame
		(holy/set-font-faces))))
    (holy/set-font-faces))

\end{verbatim}

\section*{UI Configuration}
\label{sec:org40acedb}
\subsection*{Command Log Mode}
\label{sec:org6c3f359}
command-log-mode]] 는 눌려지는 key를 화면에 표시해준다. 방송을 할때 주로 많이 쓰인다.
clm/open-command-log-buffer를 실행하면 오른쪽에 buffer가 만들어지며 keybinding을 확인할 수 있다.
\href{https://github.com/lewang/command-log-mode}{참조}
\begin{verbatim}
(use-package command-log-mode)
\end{verbatim}

\subsection*{Color Theme}
\label{sec:org934f90a}
theme는 여러 종류가 있는데, doom theme가 가장 modern하다.
\href{https://github.com/hlissner/emacs-doom-themes}{doom-themes} , \href{https://github.com/hlissner/emacs-doom-themes/tree/screenshots}{screenshots} 
\begin{itemize}
\item counsel-load-themes로 theme 둘러보기가 가능하다.
\end{itemize}
\begin{verbatim}
(use-package doom-themes
  :init (load-theme 'doom-monokai-spectrum t))
\end{verbatim}
\subsection*{Better Modeline}
\label{sec:org31c1a57}
doom-modeline]] , \href{https://github.com/seagle0128/doom-modeline\#customize}{configuration options} 

\textbf{NOTE:} doom modeline은 icon이 보여지는데, 이 아이콘은 다음과 같이 설치해야 보여진다. 
`M-x all-the-icons-install-fonts` 

\begin{itemize}
\item doom-modeline-buffer-file-name-style
\end{itemize}
buffer에 파일 경로도 보여준다.
\href{https://github.com/seagle0128/doom-modeline}{모드라인}
\begin{verbatim}

(use-package all-the-icons)

(use-package doom-modeline
  :init (doom-modeline-mode 1)
  :config (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)
  :custom ((doom-modeline-height 18)))

\end{verbatim}

\subsection*{Which Key}
\label{sec:orge572770}

\href{https://github.com/justbur/emacs-which-key}{which-key} 
Emacs에서 keybinding을 사용해서 명령어를 실행하는데, 명령어 candidates를 minibuffer에 보여준다. 예를 들어, C-x를 누르면 명령어에 대한 candidates가 보여진다.

\begin{verbatim}

(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))

\end{verbatim}

\subsection*{Ivy and Counsel}
\label{sec:orgdfc3547}

\href{https://oremacs.com/swiper/}{Ivy} 
\begin{itemize}
\item completion engine, minibuffer의 candidates를 보여주는 engine이다. 위에 봤던 which-key도 ivy의 completion의 engine을 사용한다.
\item \texttt{problem}
\end{itemize}
ivy completion의 문제가 있다. 예를 들어보자. C-x f(find-file)를 실행한다. test\textasciitilde{}.org라는 파일이 있다. 나는 새로운 file인 test.org를 새로 만들려고 한다. 그래서 mini buffer에 test.org를 친 후 엔터를 입력한다. test.org가 만들어지지 않고 test\textasciitilde{}.org가 열린다. 이것을 해결할려면 test다음에  C-M-j를 누르고 .org를 입력해야 한다.
\href{https://github.com/Yevgnen/ivy-rich}{ivy-rich} 
\begin{itemize}
\item M-x를 치면 mini buffer에 candidates가 나오는게 ivy engine을 쓰기 때문이다.

\item use-package(:diminish)
\end{itemize}
modeline에 mode를 감춘다. load되는 mode가 너무 많아지면 지저분해지기 때문이다.

\begin{verbatim}

(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
	 :map ivy-minibuffer-map
	 ("TAB" . ivy-alt-done)
	 :map ivy-switch-buffer-map
	 ("C-d" . ivy-switch-buffer-kill)
	 :map ivy-reverse-i-search-map
	 ("C-k" . ivy-previous-line)
	 ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1))

(use-package ivy-rich
  :init
  (ivy-rich-mode 1))

(use-package counsel
  :bind (("C-M-j" . 'counsel-switch-buffer)
	 :map minibuffer-local-map
	 ("C-r" . 'counsel-minibuffer-history))
  :config
  (counsel-mode 1))

\end{verbatim}

\subsection*{Helpful Help Commands}
\label{sec:org09af419}

\href{https://github.com/Wilfred/helpful}{Helpful} 
\begin{itemize}
\item describe-function, describe-variable과 같은 document는 built-in package나 counsel을 통해서 보는 것은 source와 간략한 설명뿐이다. helpful package는 좀 더 자세한 help document를 제공한다.
\end{itemize}

\begin{verbatim}

(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key] . helpful-key))

\end{verbatim}

\subsection*{Text Scaling}
\label{sec:org5a16698}

\href{https://github.com/abo-abo/hydra}{Hydra} 
\begin{itemize}
\item hydra는 keybinding을 편리하게 해주는 package다. <f2> i key 가 increase character로 define되어 있을때 글자 크기를 키우기 위해서 <f2> i ,<f2> i , <f2> i\ldots{}를 계속 눌러서 키워야 한다. 이것을 간단히 하기 위해서 hydra를 사용한다.  hydra를 사용하면 <f2> i,i,i,i\ldots{}로 계속 키울수 있다. 아래에선 hydra-text-scale이란 function을 사용하고(M-x hydra..) 메뉴형식으로 보여지게 된다.
\end{itemize}
\begin{verbatim}

  (use-package hydra)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

;  (rune/leader-keys
;    "ts" '(hydra-text-scale/body :which-key "scale text"))

\end{verbatim}

\subsection*{Multiple Window}
\label{sec:org8cae41a}
\begin{verbatim}
(use-package ace-window
:ensure t
:init
(progn
(global-set-key [remap other-window] 'ace-window)
(custom-set-faces
'(aw-leading-char-face
((t (:inherit ace-jump-face-foreground :height 3.0)))))
))
  ;; (use-package winum
  ;;    :config
  ;;    (winum-mode))
\end{verbatim}

\subsection*{highlight indented mode}
\label{sec:org8bea133}
\begin{verbatim}
(use-package highlight-indentation
  :ensure t
  :config
  (add-hook 'enh-ruby-mode-hook
	    (lambda () (highlight-indentation-current-column-mode)))
    (add-hook 'coffee-mode-hook
	  (lambda () (highlight-indentation-current-column-mode)))
  )
\end{verbatim}

\subsection*{ecb}
\label{sec:orgb143d43}
\begin{verbatim}
;;; activate ecb
;; (require 'ecb)
;; (require 'ecb-autoloads)
\end{verbatim}

\subsection*{neotree}
\label{sec:org1dfa8a8}
\begin{verbatim}
  (use-package neotree
  :ensure t)
(setq neo-theme (if (display-graphic-p) 'icons 'arrow))
\end{verbatim}
\section*{Org Mode}
\label{sec:org97d76f4}
\href{https://orgmode.org/}{Org Mode} 
\subsection*{Better Font Faces}
\label{sec:org4bd4878}
\begin{itemize}
\item -<tab>을 써서 dot으로 바꾸는 것은 regular expression을 사용한다.
\item org mode에서 header는 org-level-1,2,3,\ldots{}으로 나타낸다. 각각의 header의 size를 설정하고 Cantarell이라는 가변폰트를 사용해서 face를 정의한다.
\item code나 table의 경우는 고정폰트로 face를 정의한다.
\end{itemize}

\begin{verbatim}

(defun holy/org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
			  '(("^ *\\([-]\\) "
			     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
		  (org-level-2 . 1.1)
		  (org-level-3 . 1.05)
		  (org-level-4 . 1.0)
		  (org-level-5 . 1.1)
		  (org-level-6 . 1.1)
		  (org-level-7 . 1.1)
		  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

\end{verbatim}

\subsection*{Basic Config}
\label{sec:org63c2b96}
강의: \href{https://youtu.be/VcgjTEa0kU4}{Part 5} and \href{https://youtu.be/PNE-mgkZ6HM}{Part 6} 

[org mode setup]

\begin{itemize}
\item org-indent-mode로 정렬을 한다.
\item org file을 open하면, org-mode라는 function이 수행된다.  아래에서 use-package org도 org-mode를 수행한다고 보면된다.
\item org-indent-mode:indent는 말그대로 org mode에서는 indentation을 하겠다는 뜻이다. 새로운 줄이 시작될때 띄어쓰기가 된다.
\item varible-pitch-mode:org파일을 가변폰트로 쓰겠다는 뜻이다.
\item visual-line-mode: line이 끝날때 word wrapping으로 line이 끝난다.
\end{itemize}

[org agenda]
\begin{itemize}
\item org-agenda-start-log-mode
\item org-log-done 'time
\item org-log-into-drawer(org-add-note)
\end{itemize}

agenda는 todo header를 뜻한다. agenda가 끝나면, 끝났다는 것을 기록하고 agenda view에서 볼때 언제 끝난지 표시될 수 있어야 한다. org-log-done은 끝나는 시간을 todo header에 표시해주고, start-log-mode를 true로 하면 agenda view에서 끝난시간이 기록되어 볼 수 있다. org-log-into-drawer는 agenda에 drawer를 만든다. drawer라는것은 서랍인데 agenda와 관련한 내용을 작성하고 서랍에 넣는다고 보면된다. org mode에서 header들은 tab키로 열고 닫을수 있다. header가 아닌면서 열고 닫는 기능을 갖는 게 drawer다. C-c C-z를 누르면 quick note를 작성하는데 작성이 끝난것을 org-log-into-drawer가 t로 되어 있으면 LOGBOOK이 만들어지면서, quick note가 저장된다

\begin{itemize}
\item org-agenda-files
\end{itemize}
agenda view에서 보기 위해선 agenda들이 기록될 파일들이 특정위치에 있어야 한다.

\begin{itemize}
\item org-habit
\end{itemize}
org-modules중에 org-habit이 enable되어야 한다.
\begin{verbatim}

    (add-hook 'org-mode-hook 'org-indent-mode)

    (defun holy/org-mode-setup ()
      (org-indent-mode)
      (variable-pitch-mode 1)
      (visual-line-mode 1))

    (use-package org
      :hook (org-mode . holy/org-mode-setup)
      :config
      (setq org-ellipsis " ▾"))

;; org todo state
  (setq org-todo-keywords '((sequence "☛ TODO(t)" "|" "✔ DONE(d)")
			    (sequence "⚑ WAITING(w)" "|")
			    (sequence "|" "✘ CANCELED(c)")))
    ;;   (setq org-agenda-start-with-log-mode t)
    ;;   (setq org-log-done 'time)
    ;;   (setq org-log-into-drawer t)

      (setq org-agenda-files
	    '("~/org/tasks.org"
	      "~/org/habits.org"
	      "~/org/mail.org"
	   "~/org/birthdays.org"))

    ;;   (require 'org-habit)
    ;;   (add-to-list 'org-modules 'org-habit)
    ;;   (setq org-habit-graph-column 60)

    ;;   (setq org-todo-keywords
    ;;     '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    ;;       (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

    ;;   (setq org-refile-targets
    ;;     '(("Archive.org" :maxlevel . 1)
    ;;       ("Tasks.org" :maxlevel . 1)))

    ;;   ;; Save Org buffers after refiling!
    ;;   (advice-add 'org-refile :after 'org-save-all-org-buffers)

    ;;   (setq org-tag-alist
    ;;     '((:startgroup)
    ;;        ; Put mutually exclusive tags here
    ;;        (:endgroup)
    ;;        ("@errand" . ?E)
    ;;        ("@home" . ?H)
    ;;        ("@work" . ?W)
    ;;        ("agenda" . ?a)
    ;;        ("planning" . ?p)
    ;;        ("publish" . ?P)
    ;;        ("batch" . ?b)
    ;;        ("note" . ?n)
    ;;        ("idea" . ?i)))

    ;;   ;; Configure custom agenda views
    ;;   (setq org-agenda-custom-commands
    ;;    '(("d" "Dashboard"
    ;;      ((agenda "" ((org-deadline-warning-days 7)))
    ;;       (todo "NEXT"
    ;;         ((org-agenda-overriding-header "Next Tasks")))
    ;;       (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

    ;;     ("n" "Next Tasks"
    ;;      ((todo "NEXT"
    ;;         ((org-agenda-overriding-header "Next Tasks")))))

    ;;     ("W" "Work Tasks" tags-todo "+work-email")

    ;;     ;; Low-effort next actions
    ;;     ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
    ;;      ((org-agenda-overriding-header "Low Effort Tasks")
    ;;       (org-agenda-max-todos 20)
    ;;       (org-agenda-files org-agenda-files)))

    ;;     ("w" "Workflow Status"
    ;;      ((todo "WAIT"
    ;;             ((org-agenda-overriding-header "Waiting on External")
    ;;              (org-agenda-files org-agenda-files)))
    ;;       (todo "REVIEW"
    ;;             ((org-agenda-overriding-header "In Review")
    ;;              (org-agenda-files org-agenda-files)))
    ;;       (todo "PLAN"
    ;;             ((org-agenda-overriding-header "In Planning")
    ;;              (org-agenda-todo-list-sublevels nil)
    ;;              (org-agenda-files org-agenda-files)))
    ;;       (todo "BACKLOG"
    ;;             ((org-agenda-overriding-header "Project Backlog")
    ;;              (org-agenda-todo-list-sublevels nil)
    ;;              (org-agenda-files org-agenda-files)))
    ;;       (todo "READY"
    ;;             ((org-agenda-overriding-header "Ready for Work")
    ;;              (org-agenda-files org-agenda-files)))
    ;;       (todo "ACTIVE"
    ;;             ((org-agenda-overriding-header "Active Projects")
    ;;              (org-agenda-files org-agenda-files)))
    ;;       (todo "COMPLETED"
    ;;             ((org-agenda-overriding-header "Completed Projects")
    ;;              (org-agenda-files org-agenda-files)))
    ;;       (todo "CANC"
    ;;             ((org-agenda-overriding-header "Cancelled Projects")
    ;;              (org-agenda-files org-agenda-files)))))))

    ;;   (setq org-capture-templates
    ;;     `(("t" "Tasks / Projects")
    ;;       ("tt" "Task" entry (file+olp "~/MyWorld/Projects/OrgFiles/Tasks.org" "Inbox")
    ;;            "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

    ;;       ("j" "Journal Entries")
    ;;       ("jj" "Journal" entry
    ;;            (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
    ;;            "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
    ;;            ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
    ;;            :clock-in :clock-resume
    ;;            :empty-lines 1)
    ;;       ("jm" "Meeting" entry
    ;;            (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
    ;;            "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
    ;;            :clock-in :clock-resume
    ;;            :empty-lines 1)

    ;;       ("w" "Workflows")
    ;;       ("we" "Checking Email" entry (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
    ;;            "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

    ;;       ("m" "Metrics Capture")
    ;;       ("mw" "Weight" table-line (file+headline "~/MyWorld/Projects/OrgFiles/Metrics.org" "Weight")
    ;;        "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

    ;;   (define-key global-map (kbd "C-c j")
    ;;     (lambda () (interactive) (org-capture nil "jj")))

    ;;   (holy/org-font-setup))

\end{verbatim}

\subsubsection*{Nicer Heading Bullets}
\label{sec:orgb25a72a}
\begin{itemize}
\item 참조
\end{itemize}
\href{https://github.com/sabof/org-bullets}{org-bullets} , \href{https://github.com/integral-dw/org-superstar-mode}{org-superstar-mode} 
\begin{itemize}
\item 헤더의 level을 나타냄.
\end{itemize}

\begin{verbatim}
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "▶" "●" "○" "●")))
(font-lock-add-keywords 'org-mode
			'(("^ *\\([-]\\) "
			   (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
\end{verbatim}

\subsubsection*{wrap region(org-emphasis)}
\label{sec:org253d549}
\begin{itemize}
\item org emphasis와 동일하다. region에 text style을 적용한다.
\end{itemize}
\begin{verbatim}
  (use-package wrap-region
     :config
     (wrap-region-global-mode t)
     (wrap-region-add-wrapper "~" "~" nil 'org-mode)  ; code
     (wrap-region-add-wrapper "*" "*" nil 'org-mode)  ; bold
     (wrap-region-add-wrapper "/" "/" nil 'org-mode)  ; italic
     (wrap-region-add-wrapper "+" "+" nil 'org-mode)  ; strikethrough
     (wrap-region-add-wrapper "=" "=" nil 'org-mode)) ; verbatim

(setq org-emphasis-alist
  '(("*" (bold :foreground "Orange" ))
    ("/" (italic :foreground "Deep Sky Blue"))
    ("_" (underline :foreground "#EEE2FF"))
    ("=" (org-code :background "maroon" :foreground "white"))
    ("~" (org-verbatim  :foreground "MidnightBlue"))
    ("+" (:strike-through t))))

\end{verbatim}
\subsubsection*{Center Org Buffers}
\label{sec:orgac1d469}
참조:  \href{https://github.com/joostkremers/visual-fill-column}{visual-fill-column} 
\begin{itemize}
\item org mode의 양 side에 padding을 붙인다. text는 center로 가게 한다.
\end{itemize}

\begin{verbatim}

(defun holy/org-mode-visual-fill ()
  (setq visual-fill-column-width 100
	visual-fill-column-center-text t)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . holy/org-mode-visual-fill))

\end{verbatim}

\subsection*{Configure Babel Languages}
\label{sec:org804b3e9}

참조:  \href{https://orgmode.org/worg/org-contrib/babel/languages.html}{This page} 
\begin{itemize}
\item literate programming을 할수 있다.  babel을 하기 위해선, 여기에 programming language를 등록도 하고, 해당되는 elisp package도 설치해야 하고, system에 interpreter나 compiler가 설치 되어 있어야 한다.
\end{itemize}

\begin{verbatim}

(org-babel-do-load-languages
  'org-babel-load-languages
  '((emacs-lisp . t)
    (ruby . t)
    (python . t)))

;; (push '("conf-unix" . conf-unix) org-src-lang-modes)

\end{verbatim}
\subsection*{Structure Templates}
\label{sec:orgb3db85f}
\begin{itemize}
\item 참고
\href{https://orgmode.org/manual/Structure-Templates.html}{structure templates} , \href{https://orgmode.org/worg/org-contrib/babel/languages.html}{as it is known by Org Babel}.
\end{itemize}
<sh<tab> 을 누르면 template이 써진다.
\begin{verbatim}

;; This is needed as of Org 9.2
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))

\end{verbatim}

\subsection*{Auto-tangle Configuration Files}
\label{sec:org213c323}
\begin{itemize}
\item tangle
\end{itemize}
tangle이라는 것은 src\_block에 기술한것을 특정 파일에 쓰는 것을
뜻한다. 여기서는 emacs.org라는 파일에서 emacs에 대한 설정을
src\_block에 한다. 그런 다음 org-babel-tangle이라는 명령을 사용해서
최상단에 지정된 init.el로 쓰는 작업을 하게 된다.

\begin{verbatim}
;; Automatically tangle our Emacs.org config file when we save it
(defun holy/org-babel-tangle-config ()
  (when (string-equal (buffer-file-name)
		      (expand-file-name "~/.emacs.d/emacs.org"))
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'holy/org-babel-tangle-config)))

\end{verbatim}
\subsection*{Org-gtd}
\label{sec:org85d8de9}
\begin{verbatim}
(use-package org-gtd
  :after org
  ;; :pin melpa-stable ;; or :pin melpa as you prefer
  :demand t ;; without this, the package won't be loaded, so org-agenda won't be configured
  :custom
  ;; where org-gtd will put its files. This value is also the default one.
  (org-gtd-directory "~/gtd/")
  ;; package: https://github.com/Malabarba/org-agenda-property
  ;; this is so you can see who an item was delegated to in the agenda
  (org-agenda-property-list '("DELEGATED_TO"))
  ;; I think this makes the agenda easier to read
  (org-agenda-property-position 'next-line)
  ;; package: https://www.nongnu.org/org-edna-el/
  ;; org-edna is used to make sure that when a project task gets DONE,
  ;; the next TODO is automatically changed to NEXT.
  (org-edna-use-inheritance t)
  :config
  (org-edna-load)
  :bind
  (("C-c d c" . org-gtd-capture) ;; add item to inbox
   ("C-c d a" . org-agenda-list) ;; see what's on your plate today
   ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
   ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
   ("C-c d s" . org-gtd-show-stuck-projects)) ;; see projects that don't have a NEXT item
  :init
  (bind-key "C-c c" 'org-gtd-clarify-finalize)) ;; the keybinding to hit when you're done editing an item in the processing phase

(use-package org-agenda
  :ensure nil ;; this is how you tell use-package to manage a sub-package
  :after org-gtd ;; because we need to add the org-gtd directory to the agenda files
  :custom
  ;; use as-is if you don't have an existing org-agenda setup
  ;; otherwise push the directory to the existing list
  (org-agenda-files `(,org-gtd-directory))
  ;; a useful view to see what can be accomplished today
  (org-agenda-custom-commands '(("g" "Scheduled today and all NEXT items" ((agenda "" ((org-agenda-span 1))) (todo "NEXT"))))))


\end{verbatim}

\subsection*{Org-capture}
\label{sec:org39f98bc}
\begin{verbatim}
(define-key global-map "\C-cc" 'org-capture)
;; (setq org-default-notes-file (concat org-directory "/notes.org"))
(setq org-capture-templates
      (quote (("t" "today Todo" entry (file "~/org/2021/collection.org")
	       "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
	      ("m" "Mail Related Todo Work" entry (file "~/org/2021/collection.org")
	       "* TODO %?\n%T\n")
	      ("w" "Web Related Work" entry (file+headline "~/org/2021/collection.org" "Web Captured")
	       "* %? url is  %:link \n title is %:description \nCaptured On: %U\n body is %i")
	      ("a" "Appointment" entry (file+headline 
					"~/org/2021/collection.org" "Calendar") 
	       "* APPT %^{Description} %^g  %?  Added: %U") 
	      ("n" "Notes" entry (file+datetree 
				   "~/org/2021/collection.org")
		"* %^{Description} %^g %? Added: %U")
	      ("k" "Todo" entry (file+headline "~/org/2021/test.org" "Tasks")
		"* TODO %?\n  %i\n  %a")
	       ("b" "Buy" item (file+olp "~/org/2021/test.org" "Stuff to Buy" "House")
		"")
	      ("i" "sudden rising Idea" entry (file+datetree "~/org/2021/collection.org")
	       "* %?\n%T\n" :clock-in t :clock-resume t)
	      ("h" "Habits(always daily do)" entry (file+datetree "~/org/2021/habits.org")
	       "* %?\n%T\n" :clock-in t :clock-resume t))))

\end{verbatim}

\subsection*{org-download}
\label{sec:orgc15334e}
org모드에서 제공하는 image 처리 방법은 file system에 있는 image file을 link하는 것이다. 이것말고 이미지를  org buffer로 가져오는 다양한 방식이 있다. 외부의 image를 drag해서 이미지를 가져올수도 있고, file을 drag해서 가져올 수도 있다. osx에서 screenshot(Meta+shift+5)을 찍고 이것을 org mode에 paste할 수도 있다. 이런것들을 가능하게 해주는 package다.
\begin{verbatim}
    ;; (use-package org-download
    ;;     :after org
    ;;     :defer nil
    ;;     :custom
    ;;     (org-download-method 'directory)
    ;;     (org-download-image-dir "img")
    ;;     (org-download-heading-lvl nil)
    ;;     (org-download-timestamp "%Y%m%d-%H%M%S_")
    ;;     (org-image-actual-width 300)
    ;;     (org-download-screenshot-method "/usr/local/bin/pngpaste %s")
    ;;     :bind
    ;;     ("C-M-y" . org-download-screenshot)
    ;;     :config
    ;;     (require 'org-download)
    ;;     (org-download-enable)
    ;;     )
  ;; (use-package org-download
  ;;   :ensure t
  ;;   :defer t
  ;;   :init
  ;;   ;; Add handlers for drag-and-drop when Org is loaded.
  ;;     (with-eval-after-load 'org
  ;;       (org-download-enable)))
;; (load-file "mylisp/mydnd.el")

\end{verbatim}

\subsection*{xetex}
\label{sec:orgf422a2d}
\begin{verbatim}
;; (setq-default TeX-engine 'xetex)
;; (setq-default TeX-PDF-mode t)
\end{verbatim}

\subsection*{oblivoir 설정}
\label{sec:org577260c}
\begin{verbatim}
(add-to-list 'org-latex-classes
	  '("oblivoir"
				      "\\documentclass{oblivoir}"
				      ("\\section{%s}" . "\\section*{%s}")
				      ("\\subsection{%s}" . "\\subsection*{%s}")
				      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
				      ("\\paragraph{%s}" . "\\paragraph*{%s}")
				      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
\end{verbatim}
\section*{Development}
\label{sec:orgcca9d27}
\subsection*{company mode}
\label{sec:org9f0e390}
\begin{itemize}
\item complete anything의 준말. 모든 것을 완성시켜준다는 뜻이다. ivy도 completion engine을 가지고 있는데, 특정 keybinding 예를 들면, find-file(C-x C-f)의 경우 candidates를 minibuffer에 보여준다거나, mini buffer에서 일부 문자를 입력하면 해당되는 candidates를 보여준다. Company mode도 비슷하다. Company mode의 특징은 CAPF(Complete At Point Function)에 특화 된거 같다. buffer에서 입력한 문자열에 일치하는 function candidates popup으로 띄어준다. candidates는 어디서 가져오는가? backend가 있다. company만 설치하면, backend가 없기 때문에 이전에 친 문자열이 candidates가 된다. 아니면 mode에서 가져오는듯하다.
\end{itemize}
\textbf{scratch} buffer로 가서 help라고 치면 candidates가 보일것이다.
\begin{verbatim}
(use-package company
  :config
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 3)
  (global-company-mode t))
\end{verbatim}
\subsection*{Languages Servrer Protocol}
\label{sec:org816536c}
\subsubsection*{Language Servers}
\label{sec:org2c2b1e2}
\begin{verbatim}
;; (defun holy/lsp-mode-setup ()
;;   (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
;;   (lsp-headerline-breadscrumb-mode t))

;; (use-package lsp-mode
;;   ;; :commands (lsp lsp-deferred)
;;   ;; :hook (lsp-mode . holy/lsp-mode-setup)
;;   :init
;;   (setq lsp-keymap-prefix "C-c l")
;;   :custom
;;   (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
;;   (lsp-headerline-breadscrumb-mode t)
;;   :config
;;   (lsp-enable-which-key-integration t))
\end{verbatim}

\subsubsection*{TypeScript}
\label{sec:orgc602045}
\begin{verbatim}
(use-package typescript-mode
  :mode "\\.ts\\'"
  :hook (typescript-mode . lsp-deferred)
  :config
  (setq typescript-indent-level 2))

\end{verbatim}

\subsection*{Common Lisp [Programming Language]}
\label{sec:org57c49dc}
\begin{itemize}
\item 현재는 disable.  사용할때 설치하자.
\item system에 interpreter를 설치한다.(brew install SBCL).
\item slime을 설치한다. emacs에서는 slime을 제공한다. slime을 설치한다. slime mode가 제공하는건, system에 깔려있는 interpreter를 사용해서 code evaluation도 하지만, editor의 기능도 처리한다. definition finding, auto complete라던지 reference를 찾는 것도 지원한다.
\end{itemize}
3.quicklisp을 설치한다. quick lisp은 common lisp의 package manager다. Library Manager로 부른다.
library를 가져오고 설치하는것은 다음을 참고 한다.
\href{https://www.quicklisp.org/beta/\#installation}{참조}
quicklisp을 설치할 때, 인증관련 문제가 생길 수 있다. 이때 다음\textasciitilde{}을 \href{https://www.cs.dartmouth.edu/\~sergey/cs59/lisp/sbcl-quicklisp-install-log.txt}{참조}한다.
quicklisp이란 폴더가 만들어지는데, 이 폴더를 emacs에서 참조한다. 나중에 system에 재설치시 참조해야 한다.
\begin{itemize}
\item slime-helper에 관해
emacs에서 quicklisp을 사용하려면 helper의 도움이 있어야 한다. 그런데 이 helper는 sbcl에서 만든다.
\end{itemize}
sbcl=> (ql:quickload "quicklisp-slime-helper") 이렇게 하면
slime-helper.el이 만들어지고 이를 emacs에서 추가한다.
\begin{itemize}
\item emacs에서 slime실행(M-x slime)
\end{itemize}
\begin{verbatim}
;; (use-package slime
;; :init
;; (load (expand-file-name "~/quicklisp/slime-helper.el"))
;; (setq inferior-lisp-program "sbcl"))
\end{verbatim}
\subsection*{Prolog [Programming Language]}
\label{sec:orgb436928}
\begin{enumerate}
\item swi-prolog를 설치한다.(brew install swi-prolog)
\end{enumerate}
\subsection*{Python [Programming Language]}
\label{sec:orgca05607}
\subsection*{Projectile}
\label{sec:orgcd80b3d}

\begin{itemize}
\item 참조
\end{itemize}
\href{https://projectile.mx/}{Projectile} 
\begin{itemize}
\item project를 관리하는 app, project가 위치할 곳을 정해두고 거기서 project를 생성해야 처리가 된다.
\item projectile-rg
\end{itemize}
가장 많이 사용하는 grep인데, system에 ripgrep을 설치하고 사용한다.

\begin{verbatim}

(use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  :custom ((projectile-completion-system 'ivy))
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  ;; NOTE: Set this to the folder where you keep your Git repos!
  (when (file-directory-p "~/MyWorld/Projects/Code")
    (setq projectile-project-search-path '("~/MyWorld/Projects/Code")))
  (setq projectile-switch-project-action #'projectile-dired))

(use-package counsel-projectile
  :config (counsel-projectile-mode))

\end{verbatim}
\subsection*{Terminal}
\label{sec:org0e3497d}
\subsubsection*{terminal}
\label{sec:orgc9d3576}
vterm을 추천한다.
\begin{verbatim}
(use-package term
  :config
  (setq explicit-shell-file-name "zsh")
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

(use-package eterm-256color
  :hook (term-mode . eterm-256color-mode))

\end{verbatim}
\subsubsection*{Vterm}
\label{sec:orga3593f2}
\begin{itemize}
\item vterm을 설치하면 mgit이라던지 package manager와 꼬이는 문제가 있어보인다.
\item vterm은 emacs native terminal이라서 빠르다.
\item vterm을 사용하기 위해선, system에 cmake가 설치되어 있어야 한다. (brew install cmake libtool)
\end{itemize}
\begin{verbatim}
;; (use-package vterm
;;   :commands vterm
;;   :config
;;   (setq vterm-max-scrollback 10000))
\end{verbatim}
\subsection*{Shell}
\label{sec:org98fb03c}
eshell을 추천한다.
osx system terminal에서 open -a 'Google Chrome'하면  terminal에서 chrome browser를 open할 수 있다. 보통은 alias를 써서 chrom,firefox로 호출한다. emacs의 eshell에서 chrome이나 firefox같은 외부 프로그램을  위와 같이 실행할 수 있다면 개발에 도움이 된다. 

[1] eshell에서 외부프로그램 실행

그런데  emacs의 eshell은 system의 shell과 path와 aliase가 동기화 되지 않기 때문에 직접 만들어주던가 system의 path와 alias를 가져오는 방식으로 한다.
\begin{itemize}
\item path: exec-path를 사용
\item alias: eshell에서 alias chrome open -a "Google Chrome"를 입력하면 .emacs.d/eshell/alias에 파일로 alias가 기록된다. (ex: 현재 폴더 finder를 실행하기 위해선  alias f open .)
물론 path도 addpath라는 명령어로 eshell에 적용할수 있다. 그러나 위의 path는 exec-path를 사용하기로 한다.
path와 alias가 설정되면, eshell에서 chrome으로 chrome browser를  띄우거나, f를 눌러서 finder를 띄울 수 있다.
\end{itemize}

[2] M!(shell command)로 외부 프로그램 실행하기
path는 적용되나 alias는 적용되지 않는다. 그래서 open -a 'Google Chrome'과 같이 입력해야 한다. 이게 약간 불편하다. 
\begin{verbatim}
(defun holy/configure-eshell ()
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  (setq eshell-history-size                    10000
	 eshell-buffer-maximum-lines 10000
	 eshell-hist-ignoredups t
	 eshell-scroll-to-bottom-on-input t))

(use-package eshell-git-prompt)

(use-package eshell
  :hook (eshell-first-time-mode . holy/configure-eshell)
  :config
  (with-eval-after-load 'esh-opt
     (setq eshell-destroy-buffer-when-process-dies t)
     (setq eshell-visual-commands '("htop" "zsh" "vim" "less" "more")))
  (eshell-git-prompt-use-theme 'powerline))

 (use-package exec-path-from-shell)
 (add-hook
  'eshell-mode-hook
  (lambda ()
    (setq pcomplete-cycle-completions nil)))
\end{verbatim}
\subsection*{Magit}
\label{sec:org09546c0}
\begin{itemize}
\item 참조
\end{itemize}
\href{https://magit.vc/}{Magit} 
\begin{itemize}
\item forge
\end{itemize}
forge는 github,gitlab과의 연동을 위해서 사용한다고 한다. issues라던지, pull request를 할수 있다. 자체적으로 db를 설치한후 github이나 gitlab에서 정보를 받아서 저장한다.
\begin{itemize}
\item magit-branch-read-upstream-first 'fallback
\end{itemize}
magit에서 branch를 만드는 명령어가 안된다. 되게 해주는 setting
\begin{verbatim}

  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge)

(setq magit-branch-read-upstream-first 'fallback)
\end{verbatim}

\subsection*{Rainbow Delimiters}
\label{sec:org1774391}

\begin{itemize}
\item 참조
\end{itemize}
\href{https://github.com/Fanael/rainbow-delimiters}{rainbow-delimiters} 
parenthesis topology를 color별로 나타낸다.
show-paren-mode는 parenthesis를 쌍으로 check한다.
\begin{verbatim}

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

(show-paren-mode 1)
\end{verbatim}

\subsection*{Tramp}
\label{sec:orgf34c121}
\begin{verbatim}
;TRAMP
(require 'tramp)
(setq tramp-default-method "ssh")
\end{verbatim}
\subsection*{Ruby}
\label{sec:orgf22746c}
setting은 \href{https://worace.works/2016/06/07/getting-started-with-emacs-for-ruby/}{다음}을 참조했다.
\subsubsection*{ruby electric mode}
\label{sec:org9869e21}
\begin{verbatim}
(use-package ruby-electric
 :ensure t)
(add-hook 'ruby-mode-hook 'ruby-electric-mode)
\end{verbatim}
\subsubsection*{rbenv}
\label{sec:orge71aba1}
\begin{verbatim}
(use-package rbenv
 :ensure t
 :config
 (setq rbenv-installation-dir "/opt/homebrew/rbenv")
 (global-rbenv-mode)
 (rbenv-use-global))
\end{verbatim}
\subsubsection*{seeing is believing}
\label{sec:org901fe78}
\begin{verbatim}
;; (setq seeing-is-believing-prefix "C-.")
;; (add-hook 'ruby-mode-hook 'seeing-is-believing)
;; (require 'seeing-is-believing)
\end{verbatim}
\subsubsection*{inf-ruby}
\label{sec:org7242847}
\begin{verbatim}
(use-package inf-ruby
  :ensure t)
(autoload 'inf-ruby-minor-mode "inf-ruby" "Run an inferior Ruby process" t)
(add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)

\end{verbatim}
\subsubsection*{ruby extension settings}
\label{sec:org181159c}
\begin{verbatim}
(add-to-list 'auto-mode-alist
	     '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
(add-to-list 'auto-mode-alist
	     '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))
\end{verbatim}
\subsubsection*{ruby bundler settings}
\label{sec:org06f2ccb}
\begin{verbatim}
(add-to-list 'load-path "~/.emacs.d/vendor/bundler.el")
(require 'bundler)
\end{verbatim}
\subsubsection*{projectile rails}
\label{sec:org6a04525}
\begin{verbatim}
(use-package projectile-rails
  :ensure t
  :config
  (projectile-rails-global-mode)
  (define-key projectile-rails-mode-map (kbd "C-c r") 'projectile-rails-command-map)
  )
\end{verbatim}
\subsubsection*{rinari}
\label{sec:org608b5c4}
\subsubsection*{robe}
\label{sec:org1bc501c}
\begin{verbatim}
  (use-package robe
  :ensure t
  :config
  (global-robe-mode)
  (eval-after-load 'company
  '(push 'company-robe company-backends))
)
\end{verbatim}
\subsection*{flyspell}
\label{sec:org152111b}
osx에서는 brew install ispell을 해줘야 한다.
\begin{verbatim}
(use-package flyspell
  :ensure t
  :config
  (setq flyspell-issue-message-flg nil)
  (add-hook 'enh-ruby-mode-hook
	    (lambda () (flyspell-prog-mode)))
  (add-hook 'web-mode-hook
	  (lambda () (flyspell-prog-mode)))
  ;; (ac-flyspell-workaround)
)
;; flyspell mode breaks auto-complete mode without this.

\end{verbatim}
\subsection*{web development}
\label{sec:org84634b5}

\subsubsection*{webmode}
\label{sec:orgcf4c61b}
\begin{verbatim}
(use-package web-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.js\\'" . web-mode))
  )
(defun my-web-mode-hook ()
  "Hooks for Web mode."
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  )
(add-hook 'web-mode-hook  'my-web-mode-hook)    
(setq tab-width 2)

;; highlight of columns settings
(setq web-mode-enable-current-column-highlight t)
(setq web-mode-enable-current-element-highlight t)

;; (defun my-web-mode-hook ()
;;   (set (make-local-variable 'company-backends) '(company-css company-web-html company-yasnippet company-files))
;;   )
\end{verbatim}
\subsubsection*{emmet mode}
\label{sec:org754b9fd}
\begin{verbatim}
      (use-package emmet-mode
	:ensure t)
(add-hook 'web-mode-hook  'emmet-mode)
;; (add-hook 'web-mode-before-auto-complete-hooks
;;             '(lambda ()
;;                (let ((web-mode-cur-language
;;                       (web-mode-language-at-pos)))
;;                  (if (string= web-mode-cur-language "php")
;;                      (yas-activate-extra-mode 'php-mode)
;;                    (yas-deactivate-extra-mode 'php-mode))
;;                  (if (string= web-mode-cur-language "css")
;;                      (setq emmet-use-css-transform t)
;;                    (setq emmet-use-css-transform nil)))))
\end{verbatim}
\subsubsection*{js2 mode}
\label{sec:orgcfe8970}
\section*{File Management}
\label{sec:org6834854}
\begin{itemize}
\item \^{}, dired-jump(C-x j)
\end{itemize}
상위폴더로 이동, dired-jump는 현재 buffer에서 dired mode로 전환한다.
\begin{itemize}
\item C-o (dired-display-file)
\end{itemize}
파일을 other window에서 open
\begin{itemize}
\item dired-listing-switch
\end{itemize}
listing을 sorting한다. directory 먼저 나오고 그다음 file
\begin{itemize}
\item dired-hide-detail( open parenthesis )
\end{itemize}
파일 이름만 나오게 한다.
\begin{itemize}
\item dired-toggle-marks
\end{itemize}
하나의 파일을 m을 눌러 mark한 후 t를 누르면 mark된 파일 빼놓고 모든 파일이 mark된다.
\begin{itemize}
\item dired-mark-files-regex
\end{itemize}
\%키를 누르면 sub menu가 나온다. m(dired-mark-files-regex)을 선택하고 원하는 파일의 패턴을 입럭한다. 
예를 들면, .org\$; 이것은 org로 끝나는 파일을 의미한다.
\begin{itemize}
\item *
\end{itemize}
sub menu가 보이고 조건에  맞는 파일을 mark한다.
\begin{itemize}
\item \texttt{[copy \& rename \& move]}
\begin{itemize}
\item c 
copy single file
\item C
copy multiple marked file
\end{itemize}
.R (rename \& move)
 rename 할 이름을 입력한다.
 rename할 이름을 minibuffer에 입력할때, 원하는 폴더로 이동해서 enter를 치면 move가 된다.

\item \texttt{[ dred-dwim-target ]}
\end{itemize}
이 변수를 true로 setting하면 dwim을 사용할 수 있다. 예를 들어 dired buffer를 2개를 띄운 다음 copy를 하기 위해 C를 누르면 target의 위치가 열려진 direed buffer로 정해진다. target의 위치를 따로 정할 필요가 없다. 이런 것을 dwim이라고 한다. 

\begin{itemize}
\item \texttt{[zip,unzip]}
\end{itemize}
가장 유용한 기능중 하나. 파일을 선택하고 Z를 누르면 zip,unzip할 수 있다. 확장자는 tar.gz다.
만일 zip으로 압축하고 싶다면,
\begin{itemize}
\item dired-compress-files-alist의 값을 zip으로 하면 된다. 사용법은 describe-variable에서 살펴보면 된다.

\item \texttt{[other useful,helpful]}
\item shift-M
file mode변경
\item shift-t
\end{itemize}
=> 파일의 timestamp를 변경할 수 있다.
\begin{itemize}
\item shift-o
파일의 owner를 변경
\item shift-g
\end{itemize}
=>파일의 group을 변경
\begin{itemize}
\item shift-s
\end{itemize}
=> symbolic link를 만든다.

\begin{itemize}
\item \texttt{[all-the-icons-dired-mode]}
\end{itemize}
=> dired모드에 icon

\begin{itemize}
\item \texttt{[dired-open]}
\end{itemize}
=> dired mode에서 선택된 파일은 emacs내에서 처리한다. 외부 프로그램에서 처리하게 할 때 이 package를 설치하고 \&를 누르면 외부 프로그램을 사용할 수 있다.
예를 들어, html=>browser, png=> adobe, mp3=>mpv

\begin{itemize}
\item dired-listing-switches
\end{itemize}
이것은 dired에서 sorting해서 보여주는 설정인데, mac에서는 ls란 utility가 전체 설치가 안되어 있어서 동작하지 않는다. 이것을 사용하기 위해선 brew install coreutils를 설치해야 agho라는 option을 처리할 수 있다. 또한 다른것도 처리해야 하는데, 나는 그냥 안쓰기로 했다.

\begin{itemize}
\item \texttt{[dired-maybe-insert-subdir]}
\end{itemize}
매우 유용한 명령어, i key와 binding되어 있는데, subfolder를 볼때 새 버퍼를 띄우지 않는다. 하나의 buffer에서 subdir을 계속 보여줄 수 있다. 매우 유용한 명령어다.
\subsection*{Dired}
\label{sec:org4112402}
\begin{verbatim}
(use-package dired
:ensure nil
:commands (dired dired-jump)
:bind (("C-x C-j" . dired-jump))
;; :custom ((dired-listing-switches "-agho --group-directories-first"))
)

(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode))

;; (use-package dired-open
;;   :config
;;   (add-to-list 'dired-open-functions #'dired-open-xdg t)
;;   (setq dired-open-extensions '(("png" . "feh")
;;                                 ("mkv" . "mpv"))))

(use-package dired-hide-dotfiles
   :hook (dired-mode . dired-hide-dotfiles-mode)
   :config 
   (define-key dired-mode-map "H" 'dired-hide-dotfiles-mode))
\end{verbatim}
\section*{Applications}
\label{sec:orga62f602}
\subsection*{docker}
\label{sec:org50fb026}
\begin{verbatim}
;; (use-package docker
;;   :bind ("C-c d" . docker))
\end{verbatim}
\subsection*{email(Mu4e)}
\label{sec:org62787cf}
\begin{itemize}
\item[{$\boxtimes$}] isync 설치
local에서 gmail과 sync를 할 프로그램을 설치한다. brew install isync

\item[{$\boxtimes$}] \textasciitilde{}/.mbsyncrc를 설정한다. 여길 \href{file:///Users/holy/.mbsyncrc}{참조}
\begin{itemize}
\item Mail폴더를 만든다. subFolder에 Gmail과 Fastmail을 만든다. 이것은 imap에서 가져올 메일을 저장하는 곳이다. PATH와 INBOX설정에 기술한다.
\end{itemize}
\begin{itemize}
\item 여기서 passCmd와 certificateFile은 설명이 필요하다.
\item\relax [passCmd]: mail server에 login하기 위해선 id,pw가 필요하다. id는 위 항목중 user를 의미하고, pw는 pass를 사용했다.하지만, 지금은 pass는 보안문제로 사용되지 않는다. pass는 password를 직접 mbsyncrc파일에 기술하는 것이다. 반면  직접기록하는 대신에 특정파일에 적어놓고 이를 cat과 같은 명령어로 읽어들이거나 gpg를 사용한다. 나는 cat을 사용했고 해당 password는 gmail은 직접 파일에 기술했고, fast mail은 아래 설정에서 app password를 받아서 사용했다.
ex) "cat \textasciitilde{}/.oh-no-insecure-password"
ex) gpg --quiet --for-your-eyes-only --no-tty --decrypt \textasciitilde{}/.passwords/gmail.gpg
\item 인증서는 logbook에 적었는데, openssl을 통해서 gmail에 접속하면 gmail의 public key가 담긴 인증서를 얻을 수 있다. 얻은 인증서를 저장한 후 적용하면
\end{itemize}
\end{itemize}
\begin{itemize}
\item[{$\boxtimes$}] imap server를 설정한다. 
google gmail과 fastmail을 web에서 접속한다. 접속후 설정화면으로 간다.
\begin{itemize}
\item\relax [gmail]: \href{https://support.google.com/mail/answer/7126229?hl=en}{설정법}, two-pass인증을 사용한다면, app password를 받아야 한다.아니면 less secure app으로 접속가능하게 해야 한다. \href{https://myaccount.google.com/lesssecureapps?pli=1\&rapt=AEjHL4NfiM5-El5bbUyLjtgLtJR3Q8iaaB1U3ZOSHERUwRyureo\_rGEIPZbph5C8sgVJIyt4Ag3uL8ujJdkfLEfc9Tc93oKGlw}{참조}
\item\relax [fastmail]: settings->password->app password
\end{itemize}
\end{itemize}
\begin{itemize}
\item[{$\boxtimes$}] 설정이 끝났으면 동기화 테스트를 한다.(mbsync -a)
\begin{itemize}
\item two pass인증 에러는 Application-specific password required란 에러나 나온다.
\item \textasciitilde{}/Mails/폴더에 가서 [Gmail]Sent Mail, [Gmail]Drafts\ldots{}와 같은 폴더가 있는지 확인해 본다.
\item Error: SASL(-7): invalid parameter supplied: Parameter Error in /BuildRoot/Library/Caches/com.apple.xbs/Sources/passwordserver\_saslplugins/passwordserver\_saslplugins-192.30.1/plain\_clienttoken.c near line 195 가 나서 AuthMechs PLAIN을 설정에 추가했다.
\item Error: channel fastmail: far side box Inbox cannot be opened.
\item Maildir warning: ignoring INBOX in \emph{Users/holy/Mail/Fastmail}
=> Inbox관련 warning과 error는 mbsyncrc의 Inbox \textasciitilde{}/Mail/Fastmail/Inbox/ 에서  \textasciitilde{}/Mail/Fastmail/Inbox 로 바꿔줬더니 정상동작한다.
\end{itemize}

\item[{$\boxtimes$}] mu를 설치한다. (brew install mu)
\begin{itemize}
\item mu를 system에 설치하면, mu4e도 설치가 된다. emacs에서 mu4e를 load할때는 아래 path를 사용해서 load한다.
path: /usr/local/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e
\end{itemize}

\item[{$\boxtimes$}] mu init(예전 mu index) 실행한다. 저장된 mail에 indexing을 한다고 보면 된다. index tree를 만들어 검색을 빠르게 하는 것이다.
(mu init --maildir=\textasciitilde{}/Mail --my-address=holy.frege@gmail.com --my-address=holy\_frege@fastmail.com)

\item[{$\boxtimes$}] emacs에서 mu4e를 설정한다. 아래 코드 부분이다. mu를 설치할때 mu4e elisp들이 설치되는데 그경로(load-path)를 기술한다.
\begin{itemize}
\item 설치할 때 mu4e-meta.el이 newer than oldfile이라고 나오면 해당 load-path로가서 mu4e-meta.elc를 지우고 다시 byte compile한다.
\item 10분마다 자동 sync하기로 했다.
\item mu4e \href{https://www.djcbsoftware.nl/code/mu/mu4e/index.html}{공식문서}
\end{itemize}

\item[{$\boxtimes$}] mu4e 실행 (M-x mu4e)
\begin{itemize}
\item j o 를 누르고 maildir에서 [Gmail]/Sent Mail, [Gmail]Drafts, [Gmail]Trash,[Grmail]/All mails 이외의 것이 있나 확인한다. 왜냐면 우리는 imap에서 이 4개의 폴더로 email을 관리하고 이 폴더들이 gmail과 동기화해서 web에서 gmail을 볼때 보여야 하기 때문이다.

\item C-c C-u: mbsync -a를 실행해서 update여부를 확인한다. mu4e main화면에 u를 눌러도 된다.
\end{itemize}
\item[{$\boxtimes$}] Mu4e context(account) 설정
\end{itemize}
\begin{itemize}
\item 설정에 대한 story
\begin{itemize}
\item[{$\boxtimes$}] SMTP server 설정
\begin{itemize}
\item mu4e에서 mail계정은 context로 불리기도 한다. 각각의 계정마다 아래 smtp server 설정을 해준다. gmail과 fastmail에서 snmp정보를 찾을 수 있다. googling해서 찾아서 기입하면 된다.
\item smtpmail-smtp-server - The host where we connect to send mail
\item smtpmail-smtp-service - The port number of the SMTP service (defaults to 25)
\item smtpmail-stream-type - Determines whether SSL or TLS should be used when connecting
\end{itemize}
\end{itemize}

\item[{$\boxtimes$}] Mail 작성법
\begin{itemize}
\item C(compose)를 누른다.
\item from, to , subject를 입력한다. from, to는 <tab>으로 list중 하나를 선정 가능하다.
\item C-c C-c : send the message
\item C-c C-k : discard the message
\item C-c C-d : save message in Draft folder.
\end{itemize}

\item[{$\boxtimes$}] mail 보내기 password문제.
\begin{itemize}
\item mail을 보내기 위해 C-c C-c를 누르면 id와 pw를 물어본다. 이것을 물어보지 않고 자동화 할 수 있는 방법이 있다.
\item \textasciitilde{}/.authinfo라는 파일을 만들고 pw를 저장한다음 (setq message-send-mail-function 'stmpmail-send-it)을 설정하면, smtpmail-send-it이 호출될때, auth-source라는 library를 사용한다. 이  library는 .authinfo라는 파일에서 정보를 읽어서 접속한 server에 입력한다. auth-sources는 authinfo외에도  \textasciitilde{}/.authinfo.gpg, \textasciitilde{}/.netrc라는 파일이 있으면 자동으로 읽는다.
=> (setq message-send-mail-function 'stmpmail-send-it)을 설정하고 .authinfo에 id와 pw만 작성하면 mail을 작성해서 보낼때 id와 pw를 입력하지 않아도 되지만, 보안에 문제가 있기 때문에 .authinfo.gpg라는 파일에 id와 pw를 작성하면 자동으로 gpg encrypt와 decrypt가 실행된다.

즉 정리하면 (setq message\ldots{})와 authinfo.gpg에 id와 pw를 작성하면, mail을 작성하고 C-c  C-c를 눌러서 전송하면, 내부적으로 gpg라이브러리가 .authinfo.gpg를 decrypt한후 id와 pw을 읽어서 해당 smtp에 login하고 메시지를 전송하게 된다. 이 과정을 다시 설명해 보겠다.

\textbf{GPG 사용법}
. [1] authinfo에 다음을 기술한다.
machine smtp.fastmail.com login holy.frege@gmail.com password mypassword port 465
machine smtp.fastmail.com login holy\_frege@fastmail.com password mypassword port 465
=> fastmail은 app password를 기입하고, gmail은 2pass인증을 하지 않기 때문에 직접 pw를 입력했다.

. [2] authinfo를 encrypt 하기위해서 key를 만든다. key를 만들때 아래 질문을 참고한다.
   gpg --full-generate-key 

\begin{itemize}
\item What kind of key do you want? (1) RSA and RSA (default)
\item What keysize do you want? 4096
\item How long should the key be valid? 0 (Key does not expire)
\item Enter your name
\item Enter your e-mail address
\item Enter a comment for the key (not necessary, but can be used to identify it)
\item If everything looks good, press O for “Okay”
\item You will now be prompted for a passphrase. This is like a password for your encryption key, it should be secure and memorable!
\item After entering the password, it will generate the new key. Move the mouse around or press keyboard keys to help generate entropy.

gpg --list-keys로 key를 확인한다.
\end{itemize}
\begin{itemize}
\item\relax [3] gpg encrypt에 관해
.authinfo.gpg라는 파일을 만들고 .authinfo의 내용을 복사한다. 그리고 저장 하려고 하면 자연스럽게 encrypt menu가 뜨면서 gpg로 encrypt되어 저장된다. 이렇게 되는 이유는 gpg확장자를 갖는 파일은 무조건 gpg로 encrypt하기때문이다. 따라서 별도의 작업이 필요치는 않다. 그냥 저장하면 menu가 뜨고 menu에서 원하는 key를 선택하고 ok버튼을 누르면 encrypt되기 때문이다.

\begin{itemize}
\item\relax [4] 메일 보내기
여기까지 하고 mu4e로 들어가서 메일을 작성한 후에 C-c C-c로 메일을 보낸다.
error: no secret key가 없다면서 timeout이 걸릴 수 있다.  \href{https://emacs.stackexchange.com/questions/27841/unable-to-decrypt-gpg-file-using-emacs-but-command-line-gpg-works}{참조}에 나와 있듯이 (setf epa-pinentry-mode 'loopback)을 .emacs.org에 추가시킨다. 이러면 timeout이 안걸리고 .authinfo.gpg를 decrypt해서 id,pw를 꺼내올 수 있다.
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
\begin{verbatim}
    (use-package mu4e			
      :ensure nil
      ;; :defer 20
      ;; :load-path "/usr/local/share/emacs/site-lisp/mu/mu4e/"
      ;; brew를 사용한 경우 아래에 있다.
      ;; :load-path "/usr/local/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e/"
      :load-path "/opt/homebrew/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e"
      ;; :defer 20 ; Wait until 20 seconds after startup
      :config
      (require 'mu4e-org)


      (setq mail-user-agent 'mu4e-user-agent)
      ;; This is set to 't' to avoid mail syncing issues when using mbsync
      (setq mu4e-change-filenames-when-moving t)
      ;; Refresh mail using isync every 10 minutes
      (setq mu4e-update-interval (* 10 60))
      (setq mu4e-get-mail-command "mbsync -a")
      (setq mu4e-maildir "~/Mail")
      ;; Make sure plain text mails flow correctly for recipients
      (setq mu4e-compose-format-flowed t)

      (setq message-send-mail-function 'smtpmail-send-it)
      (setf epa-pinentry-mode 'loopback)
      ;; mu4e sending message settings(smtp)
      (setq mu4e-contexts
	 (list
	 ;; Work account(gmail-holy.frege)
	 (make-mu4e-context
	  :name "public_mail(gmail)"
	  :match-func
	    (lambda (msg)
	      (when msg
		(string-prefix-p "/Gmail" (mu4e-message-field msg :maildir))))
	  :vars '((user-mail-address . "holy.frege@gmail.com")
		  (user-full-name    . "Holy Frege work_mail")
		  (smtpmail-smtp-server  . "smtp.gmail.com")
		  (smtpmail-smtp-service . 465)
		  (smtpmail-stream-type  . ssl)
		  (mu4e-compose-signature .
		  (concat 
		       "This is my public email\n"
		       "When there's a will to fail, obstacles can be found.\n"
		       "- John McCarthy\n"))
		  (mu4e-drafts-folder  . "/Gmail/[Gmail]/Drafts")
		  (mu4e-sent-folder  . "/Gmail/[Gmail]/Sent Mail")
		  (mu4e-refile-folder  . "/Gmail/[Gmail]/All Mail")
		  (mu4e-trash-folder  . "/Gmail/[Gmail]/Trash")))

	 ;; Personal account(fastmail)
	 (make-mu4e-context
	  :name "Private_mail(fastmail)"
	  :match-func
	    (lambda (msg)
	      (when msg
		(string-prefix-p "/Fastmail" (mu4e-message-field msg :maildir))))
	  :vars '((user-mail-address . "holy_frege@fastmail.com")
		  (user-full-name    . "Holy Frege Personal_mail")
		  (smtpmail-smtp-server  . "smtp.fastmail.com")
		  (smtpmail-smtp-service . 465)
		  (smtpmail-stream-type  . ssl)
		  (mu4e-compose-signature .
		  (concat 
		       "This is my private email\n"
		       "When no idea seems right, the right one must seem wrong\n"
		       "-Marvin Minsky\n"))
		  (mu4e-drafts-folder  . "/Fastmail/Drafts")
		  (mu4e-sent-folder  . "/Fastmail/Sent")
		  (mu4e-spam-folder  . "/Fastmail/Spam")
		  (mu4e-refile-folder  . "/Fastmail/Archive")
		  (mu4e-trash-folder  . "/Fastmail/Trash")))))
      ;; %a: 메일의 title이다.
      ;; %i: mail의 특정 text영역을 block한후 paste한다. 

  ;; quick action
     (defun holy/capture-mail-follow-up (msg)
	(interactive)
	(call-interactively 'org-store-link)
	(org-capture nil "mf"))

     (defun holy/capture-mail-read-later (msg)
	(interactive)
	(call-interactively 'org-store-link)
	(org-capture nil "mr"))
	;; Add custom actions for our capture templates
     (add-to-list 'mu4e-headers-actions
	 '("follow up" . holy/capture-mail-follow-up) t)
     (add-to-list 'mu4e-view-actions
	 '("follow up" . holy/capture-mail-follow-up) t)
     (add-to-list 'mu4e-headers-actions
	 '("read later" . holy/capture-mail-read-later) t)
     (add-to-list 'mu4e-view-actions
	 '("read later" . holy/capture-mail-read-later) t)

     (setq mu4e-maildir-shortcuts
      '((:maildir "/Gmail/Inbox"    :key ?i)
	(:maildir "/Gmail/[Gmail]/Sent Mail" :key ?s)
	(:maildir "/Gmail/[Gmail]/Trash"     :key ?t)
	(:maildir "/Gmail/[Gmail]/Drafts"    :key ?d)
	(:maildir "/Gmail/[Gmail]/All Mail"  :key ?a))))
	;; run mu4e in the background to sync mail periodically
      ;; (mu4e t)  
      ;; (setq user-mail-address "holy.frege@gmail.com")
      ;; (setq smtpmail-default-smtp-server "smtp.gmail.com")
      ;; (setq smtpmail-smtp-server "smtp.gmail.com")
      ;; (setq smtpmail-smtp-service 587))

;; Use a specific key for signing by referencing its thumbprint(모든 메일에 gpg encrypt)
;; (setq mml-secure-openpgp-signers '("96136C86DAF5B7DCD7349E85FDF667618AC4B222"))
;; (add-hook 'message-send-hook 'mml-secure-message-sign-pgpmime)
\end{verbatim}

\begin{verbatim}
  (use-package org-mime
  :ensure t
    :config
    (setq org-mime-export-options '(:section-numbers nil
				    :with-author nil
				    :with-toc nil))
    (add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)
    ;; (add-hook 'message-send-hook 'org-mime-htmlize)
    (add-hook 'org-mime-html-hook
       (lambda ()
	  (org-mime-change-element-style
	   "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
			 "#E6E1DC" "#232323"))))
  )

(add-hook 'message-mode-hook
	  (lambda ()
	    (local-set-key "\C-c\M-e" 'org-mime-edit-mail-in-org-mode)))

(add-hook 'message-mode-hook
	  (lambda ()
	    (local-set-key "\C-c\M-h" 'org-mime-htmlize)))

(add-hook 'org-mode-hook
	  (lambda ()
	    (local-set-key "\C-c\M-o" 'org-mime-org-buffer-htmlize)))

(add-hook 'org-mode-hook
	  (lambda ()
	    (local-set-key "\C-c\M-s" 'org-mime-org-subtree-htmlize)))
\end{verbatim}
\begin{itemize}
\item[{$\boxtimes$}] org mode로 편지 쓰기 org mode로 편지를 쓰거나, image를
첨부하거나, 이미 있는 org file을 메일로 보낸다거나 할때
org-mime이라는 package를 사용한다. \href{https://github.com/org-mime/org-mime}{참조 }email의 body는 plain
text이다. 이것을 html포맷으로 바꿀 수 있다. org모드로 작성하고
html포맷으로 바꾸는 것이다. 이렇게 되면 link를 사용할 수 있고,
image,code block, formatted text를 사용할 수 있다는 장점이 있다.
\begin{itemize}
\item Formatted text (bold, italic, etc)
\end{itemize}
\item Headings and subheadings
\begin{itemize}
\item Links
\item Code blocks
\item Images (that get attached correctly)
\end{itemize}
… anything that org-mode can convert to HTML
\end{itemize}
\begin{enumerate}
\item mu4e에서 org 문서 작성후 htmlize해서 보내기
\begin{itemize}
\item mu4e Compose mail에서 org로 글 작성 -> org-mime-htmlize해서 보낸다.
\item mu4e Compose mail에서 editer buffer
(org-mime-edit-mail-in-org-mode) 를 실행하면 org buffer가
생긴다. 더많은 org 기능을 사용할 수 있다. 다 작성후에 C-c C-c를
누르고 org-mime-htmlize해서 보낸다. 단축키를 C-c M-e로
설정했다. 작성한 후 org-mime-htmlize(C-c C-h)를 실행후 보낸다.
\end{itemize}

\item org문서를 mail로 보내기
\begin{itemize}
\item org 문서에서 M-x org-mime org-buffer-htmlize(C-c M-o) 하면
compose창이 뜨고 바로 email로 전송할 수 있게 된다.
\end{itemize}

\item org문서의 특정 헤더를 mail로 보내기 
\begin{itemize}
\item org mode의 heading은 그 자체가 하나의 subtree다. org buffer에서
하나의 heading에 cursor를 두고 M-x
org-mime-org-subtree-htmlize(C-c M-s)를 하면 Mu4e의 Compose가
뜨고 해당 헤더를 title로 하는 메일을 보낼 수 있다.
\end{itemize}

\item org문서를 html로 바꿀때 css적용
\begin{itemize}
\item org-mime-change-element-style을 통해서 css속성을 적용할 수
있다. code는 pre 태그로 변환되는데, 이때 pre의 속성을 변경하면
된다.
\end{itemize}

\item org문서나, mu4e에서 org로 작성해서 보낼때, 이상한점.
\begin{itemize}
\item section이 보인다.
\item toc이 보인다.
\item author가 보인다.
\end{itemize}
\end{enumerate}
=> 만일 안보이게 하렴녀 org-mime-export-option을 추가한다.

\begin{enumerate}
\item 매번 mu4e에서 org-mime-htmlize를 해줘야하는 문제점.
\end{enumerate}
mu4e에서 작성하는 text는 plain text다. org로 작성해도 plain
text다. 다양한 기능을 사용하는 html로 바꾸기 위해서는 매번 mail을
작성하고 org-mime-htmlize를 해줘야한다. 이것을 자동으로 할수도
있다. 하지만, 가끔은 plain text를 필요로 하는 경우가 있기 때문에
경고창만 보내고 수동으로 org-mime-htmlize를 하는 방식을 추천한다.
(add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)
자동으로 무조건 적용하려면 (add-hook 'message-send-hook
'org-mime-htmlize)를 해주면 된다.
\href{https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-Mail-05.org}{참조} mu4e를 사용하는 주된 이유 중 하나는 mail을 org일정관리에 사용할
수 있다는 점이다. web에서 mail을 보는 대신 emacs라는 편집기에서 mail을
볼수 있고, org파일을 손쉽게 mail로 보낼수 있는것도 mu4e를 사용하는
주된 이유이긴 하나, 내 생각에 메일중에 중요한것은 org파일로 이동
시켜서 일정관리에 사용될수 있다는 점 같다. 그것이 org-capture다.

\begin{itemize}
\item 수행 시나리오 Mu4e를 실행한다. 메일 목록이 나와 있는 header view로
간다. cursor를 원하는 메일에 올려놓는다. M-x org-capture를
한다. menu에서 m을 선택하면, read later, Follow up을 선택한다.org
Edit buffer view가 보인다. 글을 작성하고 C-c C-c를 하면 헤당
header아래에 저장된다. 저장될때, mail의 link도 포함되어 있다. link를
open하면 mu4e가 다시 실행된다.  immediate-finish를 설정해서 더
빠르게 작업할 수 있다. 즉 mail의 header view에서 cursor를 특정메일에
놓고 org-capture를 하면 menu에서 m을 선택하고 어떤 항목에 넣을지를
선택만 하면 된다. org edit buffer를 띄어서 특정 내용을 적을 필요가
없다. 왜냐면 어차피 처리해야할 메일을 todo리스트로 정해서 올려만
두고 실제일은 나중에 할것이기 때문이다.

그런데 이것보다 더 빠르게 일을 처리할 수 있다. quick action을
사용하는 것이다.  quick action은 mail의 제목에 커서를 두고 M-x
org-capture를 입력하고 거기서 또 m을 누르고 r이나 f를 다시 누를
필요가 없다. mail 제목에 커서만 둔채로 a(action)을 누른다. 거기서
f,r을 눌러서 follow up, read later항목에 메일을 이동 시킬 수 있다.

\item 설정
\item mail이 저장될 org파일 설정: Org/Mail.org에 저장하기로
함. Org파일에는 2개의 header를 둔다. Read Later와 Follow
up이다. org-capture-template설정에 해당 header아래에 capture한
todo를 둘 것이다. 이제 mail을 보고, 나중에 읽고 해야 할것에는 Read
Later헤더아래에, Follow up해야 할것은 Follow 헤더 아래에 저장될
것이다.

\begin{enumerate}
\item 나머지 설정 참고
\end{enumerate}

\item org capture \%i
\end{itemize}
org-capture에서 \%i를 넣으면 mu4e 헤더뷰에서 메일을 읽고 특정 문장을 block으로 지정한후 org-capture를 하면 해당 block이 todo list에 들어간다.

\begin{itemize}
\item 여러가지 option
\end{itemize}
\%:subject
\%:from
\%:fromname
\%:to,\%:toname
\%:date 

\begin{itemize}
\item schedule과 deadline
\end{itemize}
schedule은 to do time, deadline은 to be done time이다. 스케쥴은 시작일이라고 보면 된다. project가 6월3에 스케쥴되었다는건 그때 시작한다는 뜻이다. 생일축하 파티가 6월 9일이면 그 때 시작한다는 것이다. 반드시 deadline이 있는 건 아니다. project나 task에 따라 어떤 것들은 schedule만 있고, 어떤 것은 deadline만 있고, 또 다른 어떤 것은 schedule과 deadline이 같이 있다.
\begin{enumerate}
\item schedule: \%t
\item deadline: org-read-date란 함수를 사용해서 자동으로 +2일에 끝나게 설정할 수 있다.

\item agenda file에 추가
\end{enumerate}
org/mail.org를 agenda file에 추가해야만 agenda로 관리 할 수 있다.

\begin{itemize}
\item quick action
\end{itemize}
mu4e에서 mail을 읽고 이것을 해야할일(todo)라고 판단하면 org-capture를 실행해서 org/mails.org의 todo list로 넘기는 작업을 했었는데, header view(mail list)에서 간단히 제목만 보고 to do list로 넘길수 있다. 메일을 읽지않고도 메일 제목만 보고 해야 할일로 넘길 수 있다는 것이다. 그런데 보통의 처리과정은 다음과 같다. 오늘 메일을 다 읽는다. 그리고 header view에서 처리한다. 이렇게 header view에서 처리하기 위해서는 immedietly finish를 세팅해야 한다.
\subsection*{org-alert}
\label{sec:org89f401e}
\begin{verbatim}
;; (use-package alert
;;   :ensure t)
;; (use-package org-alert
;; :custom (alert-default-style 'notifications)
;; :config
;; (setq org-alert-interval 300
;;       org-alert-notification-title "org alert reminder!")
;; (org-alert-enable))
\end{verbatim}
\subsection*{org presentation}
\label{sec:orgbd58436}
\begin{verbatim}
;(use-package org-tree-slide
;  :custom
;  (org-image-actual-width nil))

\end{verbatim}
\subsection*{readtheorg}
\label{sec:orgaafbd5d}
\subsection*{reveal.js}
\label{sec:orgb867f26}

\subsection*{lorem ipsum}
\label{sec:orgf3a9196}
\begin{itemize}
\item lorem ipsum은 의미없는 문자열을 만들어낸다.
\end{itemize}
\begin{verbatim}
(use-package lorem-ipsum
:config
(lorem-ipsum-use-default-bindings))
\end{verbatim}
\subsection*{yasnippet}
\label{sec:org192841e}
\begin{itemize}
\item yasnippet은 특정 단어를  template과 replace할 수 있다. 특정 단어를 tab을 누르면 이미 저장된 template으로 대치된다.
\end{itemize}
\begin{verbatim}
(use-package yasnippet
  :init
  (yas-global-mode 1)
  ;; (add-to-list 'yas-snippet-dirs "~/Dropbox/WorkSpace/emacs/snippets")
  (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
  :bind
  ("C-c s" . yas-insert-snippet)
  ("C-c n" . yas-new-snippet)
  ("C-c v" . yas-visit-snippet-file))
\end{verbatim}
\subsection*{mobileorg}
\label{sec:org7a1f684}
\begin{itemize}
\item mobileorg는 protocol이다. server로 dropbox를 사용한다.
capture한 내용은 server의 mobile.org에 저장된다.
\end{itemize}
\begin{verbatim}
;; Set to the location of your Org files on your local system
(setq org-directory "~/org")
;; Set to the name of the file where new notes will be stored
(setq org-mobile-inbox-for-pull "~/org/flagged.org")
;; Set to <your Dropbox root directory>/MobileOrg.
(setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
\end{verbatim}
\subsection*{epresent}
\label{sec:org106c388}
\begin{verbatim}
(use-package epresent
:ensure t)
\end{verbatim}
\end{document}
