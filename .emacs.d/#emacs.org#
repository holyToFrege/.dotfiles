# ------------------------------------------------------------------------------
#+TITLE: Emacs From Scratch Configuration    
#+SUBTITLE:  Holy Frege - June 2021
#+AUTHOR:    Holy Frege
#+EMAIL:     holy_frege@fastmail.com
#+LANGUAGE:  en
#+STARTUP:   content showstars indent inlineimages hideblocks
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="GTD.css" />
#+OPTIONS:   toc:2 html-scripts:nil num:nil html-postamble:nil html-style:nil ^:nil
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes
# ------------------------------------------------------------------------------

* Start!
:About_Setting:
기본적인 것을 설정한다. emacs.org는 .emac.d폴더에 넣어 둔다. 그리고 수정할때 마다, 추가할 때 마다 tangle에 의해서 자동으로 init.el이 만들어진다.
- =[ evaluation ]=
- eval-buffer
buffer 전체를 해석한다.
- C-x e
한문장을 해석한다.
- M-: 
minibuffer에서 해석한다.  현재의 mode에서 실행할 수 있는 장점이 있다.
- ns-command-modifier: command키를 meta로 한다.
- make-backup-files:  backup file을 만들지 않는다.
  - server socket directory: emacs --daemon=a라고 하면 a라는  server socket file이 해당 폴더에 저장된다.
:end:
:About_EmacsDaemon:
- (server-start)
  emacs를 실행시키면 server가 된다. frame을 닫으면 server도 stop된다. 즉 emacs화면을 유지한 상태에서 emacsclient의 접속을 받아 server의 기능을 유지한다. 우리는 화면(frame)을 닫아도 background에서 도는 daemon을 원하기 때문에 이 방법은 쓸 수 없다.
-  emacs --daemon
  emacs의 configuration을 실행한 후 daemon이 된다. background에서 계속 돈다.
  - emacs --daemon=one_daemon
    emacs daemon에 이름을 줘서 여러개의 daemon을 만들 수 있다.

- [문제]
   emacs --daemon으로 실행할 때 init.el을 실행한다. 그리고 daemon으로 동작한다. 이때 emacsclient -c로 새로운 frame을 만들고 접속할때, 이상한 frame이 만들어진다. font나 modeline이 이상하게 보여진다. 이것은 처음 만들어진 frame에서만 발생되는 현상이다. 그 이후에 frame을 만들면 정상적으로 보인다. 이것은 emacsclient -c가 first frame을 만들때 font나 modeline의 설정을 init.el에 있는것이 아닌 default값을 쓰기 때문이다. 즉 emacs daemon이 실행하면서 설정한 값들이 emacsclient -c로  실행될 때 init.el에 기술된 설정을 적용하지 않는것이다.
- [해결법]
   daemon이 init.el을 적용할때 hook을 걸어두는 것이다. frame이 만들어진 이후에 font나 modeline을 설정하게 만드는 함수를 만들고 hook을 걸어둔다. deamon이 hook을 실행하고,모든 설정을 수행한 후에 deamon을 돌고 emacsclient -c로 연결을 하면, frame이 만들어지는데 이때 hook이 실행되는 원리다. 약간 설명이 미흡한데 자세한 동작원리를 모르기 때문이다.
   
- initial-frame-alist, default-frame-alist
  frame 설정에 관련된 값들이 key,value쌍으로 저장된다. 최초의 frame관련 설정은 initial-frame-alist에 있고, default는 그 이후 만들어지는 frame에 대한 설정을 가지고 있다. 

- [emacs server 사용법]
  emacs --fd-daemon은 emacs daemon을 동작시킨다. daemon은 socket file을 가지고 있는데, 그 위치를 emacs.org설정파일에 /tmp/emacs1000/server라는 이름으로 기술되어 있다. emacsclient는 daemon에 접속하기 위해서 emacsclient -c --server-socket-name=/tmp/emacs1000/server를 기술해야만 접속이 가능하다. 

:end:

#+begin_src emacs-lisp

  (setq ns-command-modifier 'meta)
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq make-backup-files nil)
  (setq server-socket-dir "/tmp/emacs1000")
  (defvar holy/default-font-size 200)
  (defvar holy/default-variable-font-size 200)
#+end_src

* Package System Setup

** default package settings
:AboutSetting:
emacs의 package관리 시스템은 old-school인 package가 있고, modern한 use-package가 있다. use-package로 package를 관리한다. 
- package-archive
 package repo를 지정한다.
- package-archive-contents
package repo마다 가지고 있는 package 목록과 설치여부를 표시한 list
- package-initialize
package-archive-contents에 installed로 표시된 package를 설치하고 load(autoload지시자가 있는 function을 실행)한다.
- package-refresh-contents
package-archive-content를 update한다.
- use-package-always-ensure
use-package는 package를 install, load, config할 수 있는데, install을 할때 ensure:t를 해주면 package가 system에 없을 경우 down받아서 install해준다. use-package를 사용하는 모든 경우에 system설치 여부를 확인하고 없으면 install하겠다는 function이다.
:END:
#+begin_src emacs-lisp 

  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

    ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)

#+end_src
** automatically update packages
:AboutSetting:
- upgrade, update
설치된 package를 update하려면, M-x list-package를 통해 repo에서 새로운 package content list를 다운받아서 비교를 통해서 update항목을 알려준다. U를 눌러 update를 하고 x를 눌러 실행한다. 매번 list-package로 update 유무를 판단하는것은 힘들다. 자동으로 하는 설정이다.
7일, 오전 9시에 update를 하고 하기전에 prompt로 물어보게 했다.
=NOTE=
package update는 잘못된 package를 update를 할경우 설정이 꼬일 수 있다. 그래서 안사용해도 된다.
:end:
#+begin_src emacs-lisp

(use-package auto-package-update
   :custom
   (auto-package-update-interval 7)
   (auto-package-update-prompt-before-update t)
   (auto-package-update-hide-results t)
   :config
   (auto-package-update-maybe)
   (auto-package-update-at-time "09:00"))
#+end_src
* Basic UI Configuration
:About_Setting:
- fringe-mode
 보여지는 화면의 좌우 여백(padding)을 준다고 생각하면 된다.
- do-list
do-list는 python의 for 변수 in 배열 구문으로 보면된다.
4가지 mode에는 line number를 disable하겠다는 뜻이다.
:end:
#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)            ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)

  (column-number-mode)
  (global-display-line-numbers-mode t)

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src
** mark 영역 color설정
  - mark 영역의 색을 변경한다.
   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'region nil :background "#834")
  #+END_SRC
** Font Configuration
:AboutSetting:
- system에 설치되어야 하는 font는 2가지다. fixed-pitch-font(fira code; for coding), variable-pitch-font(문서작성용) 아래에서 다운받는다.
[[https://github.com/tonsky/FiraCode][Fira Code]] ,[[https://fonts.google.com/specimen/Cantarell][Cantarell]] 
- 아래 설정에 3개의 이름의 face가 설정되어 있다. default,fixed-pitch,variable-pitch 이런 이름으로 선언만 한것이다. mode에 진입하면, mode의 구성요소별로 해당 face를 선택할 수 있다. face가 없는것은 default란 이름의 face가 적용되기 때문에 대부분의 mode에서는 fira code retina 폰트로 설정될 것이다. variable-pitch-mode에서는 variable-pitch를 face로 사용하기 때문에 Cantarell로 보일 것이다.
:End:
#+begin_src emacs-lisp

     (defun holy/set-font-faces ()		
       (message "Setting faces!")
       (set-face-attribute 'default nil :font "FiraCode-Retina" :height holy/default-font-size)

           ;; Set the fixed pitch face
       (set-face-attribute 'fixed-pitch nil :font "Fira-Code Retina" :height holy/default-font-size)

           ;; Set the variable pitch face
       (set-face-attribute 'variable-pitch nil :font "Cantarell" :height holy/default-font-size :weight 'regular)
  )

    (if (daemonp)
        (add-hook 'after-make-frame-functions
           (lambda (frame)
                   (setq doom-modeline-icon t)
		     (message "Deamon faces!")
               (with-selected-frame frame
                    (holy/set-font-faces))))
        (holy/set-font-faces))

#+end_src

* UI Configuration
** Command Log Mode
:AboutSetting:
command-log-mode]] 는 눌려지는 key를 화면에 표시해준다. 방송을 할때 주로 많이 쓰인다.
clm/open-command-log-buffer를 실행하면 오른쪽에 buffer가 만들어지며 keybinding을 확인할 수 있다.
[[https://github.com/lewang/command-log-mode][참조]]
:end:
#+begin_src emacs-lisp
(use-package command-log-mode)
#+end_src

** Color Theme
:About_Setting:
theme는 여러 종류가 있는데, doom theme가 가장 modern하다.
[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] , [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][screenshots]] 
- counsel-load-themes로 theme 둘러보기가 가능하다.
:end:
#+begin_src emacs-lisp
(use-package doom-themes
  :init (load-theme 'doom-monokai-spectrum t))
#+end_src
** Better Modeline
:About_Setting:
doom-modeline]] , [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] 

*NOTE:* doom modeline은 icon이 보여지는데, 이 아이콘은 다음과 같이 설치해야 보여진다. 
`M-x all-the-icons-install-fonts` 

- doom-modeline-buffer-file-name-style
buffer에 파일 경로도 보여준다.
[[https://github.com/seagle0128/doom-modeline][모드라인]]
:end:
#+begin_src emacs-lisp

(use-package all-the-icons)

(use-package doom-modeline
  :init (doom-modeline-mode 1)
  :config (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)
  :custom ((doom-modeline-height 18)))

#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] 
Emacs에서 keybinding을 사용해서 명령어를 실행하는데, 명령어 candidates를 minibuffer에 보여준다. 예를 들어, C-x를 누르면 명령어에 대한 candidates가 보여진다.

#+begin_src emacs-lisp

(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))

#+end_src

** Ivy and Counsel

[[https://oremacs.com/swiper/][Ivy]] 
- completion engine, minibuffer의 candidates를 보여주는 engine이다. 위에 봤던 which-key도 ivy의 completion의 engine을 사용한다.
- =problem=
ivy completion의 문제가 있다. 예를 들어보자. C-x f(find-file)를 실행한다. test~.org라는 파일이 있다. 나는 새로운 file인 test.org를 새로 만들려고 한다. 그래서 mini buffer에 test.org를 친 후 엔터를 입력한다. test.org가 만들어지지 않고 test~.org가 열린다. 이것을 해결할려면 test다음에  C-M-j를 누르고 .org를 입력해야 한다.
[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] 
- M-x를 치면 mini buffer에 candidates가 나오는게 ivy engine을 쓰기 때문이다. 

- use-package(:diminish)
modeline에 mode를 감춘다. load되는 mode가 너무 많아지면 지저분해지기 때문이다.

#+begin_src emacs-lisp

    (use-package ivy
      :diminish
      :bind (("C-s" . swiper)
             :map ivy-minibuffer-map
             ("TAB" . ivy-alt-done)
             :map ivy-switch-buffer-map
             ("C-d" . ivy-switch-buffer-kill)
             :map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-d" . ivy-reverse-i-search-kill))
      :config
      (ivy-mode 1))

    (use-package ivy-rich
      :init
      (ivy-rich-mode 1))

    (use-package counsel
      :bind (("C-M-j" . 'counsel-switch-buffer)
             :map minibuffer-local-map
             ("C-r" . 'counsel-minibuffer-history))
      :config
      (counsel-mode 1))

#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] 
-  describe-function, describe-variable과 같은 document는 built-in package나 counsel을 통해서 보는 것은 source와 간략한 설명뿐이다. helpful package는 좀 더 자세한 help document를 제공한다.

#+begin_src emacs-lisp

  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src

** Text Scaling

 [[https://github.com/abo-abo/hydra][Hydra]] 
- hydra는 keybinding을 편리하게 해주는 package다. <f2> i key 가 increase character로 define되어 있을때 글자 크기를 키우기 위해서 <f2> i ,<f2> i , <f2> i...를 계속 눌러서 키워야 한다. 이것을 간단히 하기 위해서 hydra를 사용한다.  hydra를 사용하면 <f2> i,i,i,i...로 계속 키울수 있다. 아래에선 hydra-text-scale이란 function을 사용하고(M-x hydra..) 메뉴형식으로 보여지게 된다.
#+begin_src emacs-lisp

  (use-package hydra)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

;  (rune/leader-keys
;    "ts" '(hydra-text-scale/body :which-key "scale text"))

#+end_src

** Multiple Window
#+begin_src emacs-lisp
  (use-package ace-window)
  (use-package winum
     :config
     (winum-mode))
#+end_src

* Org Mode
[[https://orgmode.org/][Org Mode]] 
** Better Font Faces
-  -<tab>을 써서 dot으로 바꾸는 것은 regular expression을 사용한다.
- org mode에서 header는 org-level-1,2,3,...으로 나타낸다. 각각의 header의 size를 설정하고 Cantarell이라는 가변폰트를 사용해서 face를 정의한다.
- code나 table의 경우는 고정폰트로 face를 정의한다.

#+begin_src emacs-lisp

  (defun holy/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

#+end_src

** Basic Config
:org_gtd:
강의: [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] 

[org mode setup]

- org-indent-mode로 정렬을 한다. 
- org file을 open하면, org-mode라는 function이 수행된다.  아래에서 use-package org도 org-mode를 수행한다고 보면된다.
- org-indent-mode:indent는 말그대로 org mode에서는 indentation을 하겠다는 뜻이다. 새로운 줄이 시작될때 띄어쓰기가 된다.
- varible-pitch-mode:org파일을 가변폰트로 쓰겠다는 뜻이다.
- visual-line-mode: line이 끝날때 word wrapping으로 line이 끝난다.

[org agenda]
- org-agenda-start-log-mode
- org-log-done 'time
- org-log-into-drawer(org-add-note)

agenda는 todo header를 뜻한다. agenda가 끝나면, 끝났다는 것을 기록하고 agenda view에서 볼때 언제 끝난지 표시될 수 있어야 한다. org-log-done은 끝나는 시간을 todo header에 표시해주고, start-log-mode를 true로 하면 agenda view에서 끝난시간이 기록되어 볼 수 있다. org-log-into-drawer는 agenda에 drawer를 만든다. drawer라는것은 서랍인데 agenda와 관련한 내용을 작성하고 서랍에 넣는다고 보면된다. org mode에서 header들은 tab키로 열고 닫을수 있다. header가 아닌면서 열고 닫는 기능을 갖는 게 drawer다. C-c C-z를 누르면 quick note를 작성하는데 작성이 끝난것을 org-log-into-drawer가 t로 되어 있으면 LOGBOOK이 만들어지면서, quick note가 저장된다

- org-agenda-files
agenda view에서 보기 위해선 agenda들이 기록될 파일들이 특정위치에 있어야 한다.

- org-habit
org-modules중에 org-habit이 enable되어야 한다.
:end:
#+begin_src emacs-lisp

  (add-hook 'org-mode-hook 'org-indent-mode)

  (defun holy/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    :hook (org-mode . holy/org-mode-setup)
    :config
    (setq org-ellipsis " ▾"))

  ;;   (setq org-agenda-start-with-log-mode t)
  ;;   (setq org-log-done 'time)
  ;;   (setq org-log-into-drawer t)

  ;;   (setq org-agenda-files
  ;;         '("~/org/tasks.org"
  ;;           "~/org/habits.org"
  ;;           "~/org/mail.org"
  ;;        "~/org/birthdays.org"))

  ;;   (require 'org-habit)
  ;;   (add-to-list 'org-modules 'org-habit)
  ;;   (setq org-habit-graph-column 60)

  ;;   (setq org-todo-keywords
  ;;     '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
  ;;       (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

  ;;   (setq org-refile-targets
  ;;     '(("Archive.org" :maxlevel . 1)
  ;;       ("Tasks.org" :maxlevel . 1)))

  ;;   ;; Save Org buffers after refiling!
  ;;   (advice-add 'org-refile :after 'org-save-all-org-buffers)

  ;;   (setq org-tag-alist
  ;;     '((:startgroup)
  ;;        ; Put mutually exclusive tags here
  ;;        (:endgroup)
  ;;        ("@errand" . ?E)
  ;;        ("@home" . ?H)
  ;;        ("@work" . ?W)
  ;;        ("agenda" . ?a)
  ;;        ("planning" . ?p)
  ;;        ("publish" . ?P)
  ;;        ("batch" . ?b)
  ;;        ("note" . ?n)
  ;;        ("idea" . ?i)))

  ;;   ;; Configure custom agenda views
  ;;   (setq org-agenda-custom-commands
  ;;    '(("d" "Dashboard"
  ;;      ((agenda "" ((org-deadline-warning-days 7)))
  ;;       (todo "NEXT"
  ;;         ((org-agenda-overriding-header "Next Tasks")))
  ;;       (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

  ;;     ("n" "Next Tasks"
  ;;      ((todo "NEXT"
  ;;         ((org-agenda-overriding-header "Next Tasks")))))

  ;;     ("W" "Work Tasks" tags-todo "+work-email")

  ;;     ;; Low-effort next actions
  ;;     ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
  ;;      ((org-agenda-overriding-header "Low Effort Tasks")
  ;;       (org-agenda-max-todos 20)
  ;;       (org-agenda-files org-agenda-files)))

  ;;     ("w" "Workflow Status"
  ;;      ((todo "WAIT"
  ;;             ((org-agenda-overriding-header "Waiting on External")
  ;;              (org-agenda-files org-agenda-files)))
  ;;       (todo "REVIEW"
  ;;             ((org-agenda-overriding-header "In Review")
  ;;              (org-agenda-files org-agenda-files)))
  ;;       (todo "PLAN"
  ;;             ((org-agenda-overriding-header "In Planning")
  ;;              (org-agenda-todo-list-sublevels nil)
  ;;              (org-agenda-files org-agenda-files)))
  ;;       (todo "BACKLOG"
  ;;             ((org-agenda-overriding-header "Project Backlog")
  ;;              (org-agenda-todo-list-sublevels nil)
  ;;              (org-agenda-files org-agenda-files)))
  ;;       (todo "READY"
  ;;             ((org-agenda-overriding-header "Ready for Work")
  ;;              (org-agenda-files org-agenda-files)))
  ;;       (todo "ACTIVE"
  ;;             ((org-agenda-overriding-header "Active Projects")
  ;;              (org-agenda-files org-agenda-files)))
  ;;       (todo "COMPLETED"
  ;;             ((org-agenda-overriding-header "Completed Projects")
  ;;              (org-agenda-files org-agenda-files)))
  ;;       (todo "CANC"
  ;;             ((org-agenda-overriding-header "Cancelled Projects")
  ;;              (org-agenda-files org-agenda-files)))))))

  ;;   (setq org-capture-templates
  ;;     `(("t" "Tasks / Projects")
  ;;       ("tt" "Task" entry (file+olp "~/MyWorld/Projects/OrgFiles/Tasks.org" "Inbox")
  ;;            "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

  ;;       ("j" "Journal Entries")
  ;;       ("jj" "Journal" entry
  ;;            (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
  ;;            "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
  ;;            ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
  ;;            :clock-in :clock-resume
  ;;            :empty-lines 1)
  ;;       ("jm" "Meeting" entry
  ;;            (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
  ;;            "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
  ;;            :clock-in :clock-resume
  ;;            :empty-lines 1)

  ;;       ("w" "Workflows")
  ;;       ("we" "Checking Email" entry (file+olp+datetree "~/MyWorld/Projects/OrgFiles/Journal.org")
  ;;            "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

  ;;       ("m" "Metrics Capture")
  ;;       ("mw" "Weight" table-line (file+headline "~/MyWorld/Projects/OrgFiles/Metrics.org" "Weight")
  ;;        "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

  ;;   (define-key global-map (kbd "C-c j")
  ;;     (lambda () (interactive) (org-capture nil "jj")))

  ;;   (holy/org-font-setup))

#+end_src

*** Nicer Heading Bullets
- 참조
[[https://github.com/sabof/org-bullets][org-bullets]] , [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] 
- 헤더의 level을 나타냄.

#+begin_src emacs-lisp
  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
(font-lock-add-keywords 'org-mode
                            '(("^ +\\([-*]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

*** wrap region(org-emphasis)
- org emphasis와 동일하다. region에 text style을 적용한다. 
#+BEGIN_SRC emacs-lisp 
  (use-package wrap-region
     :config
     (wrap-region-global-mode t)
     (wrap-region-add-wrapper "~" "~" nil 'org-mode)  ; code
     (wrap-region-add-wrapper "*" "*" nil 'org-mode)  ; bold
     (wrap-region-add-wrapper "/" "/" nil 'org-mode)  ; italic
     (wrap-region-add-wrapper "+" "+" nil 'org-mode)  ; strikethrough
     (wrap-region-add-wrapper "=" "=" nil 'org-mode)) ; verbatim

(setq org-emphasis-alist
  '(("*" (bold :foreground "Orange" ))
    ("/" (italic :foreground "Deep Sky Blue"))
    ("_" (underline :foreground "#EEE2FF"))
    ("=" (org-code :background "maroon" :foreground "white"))
    ("~" (org-verbatim  :foreground "MidnightBlue"))
    ("+" (:strike-through t))))

#+END_SRC
*** Center Org Buffers
참조:  [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] 
- org mode의 양 side에 padding을 붙인다. text는 center로 가게 한다.

#+begin_src emacs-lisp

  (defun holy/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . holy/org-mode-visual-fill))

#+end_src

** Configure Babel Languages

참조:  [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] 
- literate programming을 할수 있다.  babel을 하기 위해선, 여기에 programming language를 등록도 하고, 해당되는 elisp package도 설치해야 하고, system에 interpreter나 compiler가 설치 되어 있어야 한다.

#+begin_src emacs-lisp

  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (python . t)))

  ;; (push '("conf-unix" . conf-unix) org-src-lang-modes)

#+end_src
** Structure Templates
- 참고
 [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] , [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].
<sh<tab> 을 누르면 template이 써진다.
#+begin_src emacs-lisp

  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src

** Auto-tangle Configuration Files
- tangle
tangle이라는 것은 src_block에 기술한것을 특정 파일에 쓰는 것을
뜻한다. 여기서는 emacs.org라는 파일에서 emacs에 대한 설정을
src_block에 한다. 그런 다음 org-babel-tangle이라는 명령을 사용해서
최상단에 지정된 init.el로 쓰는 작업을 하게 된다.

#+begin_src emacs-lisp 
  ;; Automatically tangle our Emacs.org config file when we save it
  (defun holy/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/.emacs.d/emacs.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'holy/org-babel-tangle-config)))
#+end_src

** Org-gtd
#+BEGIN_SRC emacs-lisp 
  (use-package org-gtd
    :after org
    ;; :pin melpa-stable ;; or :pin melpa as you prefer
    :demand t ;; without this, the package won't be loaded, so org-agenda won't be configured
    :custom
    ;; where org-gtd will put its files. This value is also the default one.
    (org-gtd-directory "~/gtd/")
    ;; package: https://github.com/Malabarba/org-agenda-property
    ;; this is so you can see who an item was delegated to in the agenda
    (org-agenda-property-list '("DELEGATED_TO"))
    ;; I think this makes the agenda easier to read
    (org-agenda-property-position 'next-line)
    ;; package: https://www.nongnu.org/org-edna-el/
    ;; org-edna is used to make sure that when a project task gets DONE,
    ;; the next TODO is automatically changed to NEXT.
    (org-edna-use-inheritance t)
    :config
    (org-edna-load)
    :bind
    (("C-c d c" . org-gtd-capture) ;; add item to inbox
     ("C-c d a" . org-agenda-list) ;; see what's on your plate today
     ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
     ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
     ("C-c d s" . org-gtd-show-stuck-projects)) ;; see projects that don't have a NEXT item
    :init
    (bind-key "C-c c" 'org-gtd-clarify-finalize)) ;; the keybinding to hit when you're done editing an item in the processing phase

  (use-package org-agenda
    :ensure nil ;; this is how you tell use-package to manage a sub-package
    :after org-gtd ;; because we need to add the org-gtd directory to the agenda files
    :custom
    ;; use as-is if you don't have an existing org-agenda setup
    ;; otherwise push the directory to the existing list
    (org-agenda-files `(,org-gtd-directory))
    ;; a useful view to see what can be accomplished today
    (org-agenda-custom-commands '(("g" "Scheduled today and all NEXT items" ((agenda "" ((org-agenda-span 1))) (todo "NEXT"))))))

  (use-package org-capture
    :ensure nil
    ;; note that org-gtd has to be loaded before this
    :after org-gtd
    :config
    ;; use as-is if you don't have an existing set of org-capture templates
    ;; otherwise add to existing setup
    ;; you can of course change the letters, too
    (setq org-capture-templates `(("i" "Inbox"
                                   entry (file ,(org-gtd--path org-gtd-inbox-file-basename))
                                   "* %?\n%U\n\n  %i"
                                   :kill-buffer t)
                                  ("l" "Todo with link"
                                   entry (file ,(org-gtd--path org-gtd-inbox-file-basename))
                                   "* %?\n%U\n\n  %i\n  %a"
                                   :kill-buffer t))))
#+END_SRC

** Org-protocol
#+BEGIN_SRC emacs-lisp
  ; https://cestlaz.github.io/posts/using-emacs-24-capture-2/
  ; Bind Key to: emacsclient -ne "(make-capture-frame)"


#+END_SRC

** org-download
   org모드에서 제공하는 image 처리 방법은 file system에 있는 image file을 link하는 것이다. 이것말고 이미지를  org buffer로 가져오는 다양한 방식이 있다. 외부의 image를 drag해서 이미지를 가져올수도 있고, file을 drag해서 가져올 수도 있다. osx에서 screenshot(Meta+shift+5)을 찍고 이것을 org mode에 paste할 수도 있다. 이런것들을 가능하게 해주는 package다.
#+BEGIN_SRC emacs-lisp
      ;; (use-package org-download
      ;;     :after org
      ;;     :defer nil
      ;;     :custom
      ;;     (org-download-method 'directory)
      ;;     (org-download-image-dir "img")
      ;;     (org-download-heading-lvl nil)
      ;;     (org-download-timestamp "%Y%m%d-%H%M%S_")
      ;;     (org-image-actual-width 300)
      ;;     (org-download-screenshot-method "/usr/local/bin/pngpaste %s")
      ;;     :bind
      ;;     ("C-M-y" . org-download-screenshot)
      ;;     :config
      ;;     (require 'org-download)
      ;;     (org-download-enable)
      ;;     )
    ;; (use-package org-download
    ;;   :ensure t
    ;;   :defer t
    ;;   :init
    ;;   ;; Add handlers for drag-and-drop when Org is loaded.
    ;;     (with-eval-after-load 'org
    ;;       (org-download-enable)))
  ;; (load-file "mylisp/mydnd.el")

#+END_SRC

* Development
** company mode
:설명:
  - complete anything의 준말. 모든 것을 완성시켜준다는 뜻이다. ivy도 completion engine을 가지고 있는데, 특정 keybinding 예를 들면, find-file(C-x C-f)의 경우 candidates를 minibuffer에 보여준다거나, mini buffer에서 일부 문자를 입력하면 해당되는 candidates를 보여준다. Company mode도 비슷하다. Company mode의 특징은 CAPF(Complete At Point Function)에 특화 된거 같다. buffer에서 입력한 문자열에 일치하는 function candidates popup으로 띄어준다. candidates는 어디서 가져오는가? backend가 있다. company만 설치하면, backend가 없기 때문에 이전에 친 문자열이 candidates가 된다. 아니면 mode에서 가져오는듯하다.
    
:end:
:testing:
*scratch* buffer로 가서 help라고 치면 candidates가 보일것이다.
:end:
    #+begin_src emacs-lisp
      (use-package company
        :config
        (setq company-idle-delay 0)
        (setq company-minimum-prefix-length 3)
        (global-company-mode t))
    #+end_src
** Languages Servrer Protocol
:LOGBOOK:
- Note taken on [2021-05-23 Sun 15:09] \\
  - Language server protocol은 editor에서 programming을 하는데 필요한 기능인
    1) code completion(자동완성)
    2) Hover(마우스 커서를  특정 함수나 변수에 올렸을때 설명이 나온다.)
    3) Jump to definition (변수나 함수의 정의로 이동)
    4) Workspace Symbols (symbol을 볼 수 있어야 한다.)
    5) Find References (symbol을 참조하는 code를 찾을 수 있어야 한다.)
    6) Diagnostics
  을 server와 통신을 통해서 구현한다는 것이다.
:END:
*** Language Servers

#+begin_src emacs-lisp
  ;; (defun holy/lsp-mode-setup ()
  ;;   (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  ;;   (lsp-headerline-breadscrumb-mode t))

  (use-package lsp-mode
    ;; :commands (lsp lsp-deferred)
    ;; :hook (lsp-mode . holy/lsp-mode-setup)
    :init
    (setq lsp-keymap-prefix "C-c l")
    :custom
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadscrumb-mode t)
    :config
    (lsp-enable-which-key-integration t))
#+end_src

*** TypeScript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2))

#+end_src

** Common Lisp [Programming Language]
:설치:
1. system에 interpreter를 설치한다.(brew install SBCL).
2. slime을 설치한다. emacs에서는 slime을 제공한다. slime을 설치한다. slime mode가 제공하는건, system에 깔려있는 interpreter를 사용해서 code evaluation도 하지만, editor의 기능도 처리한다. definition finding, auto complete라던지 reference를 찾는 것도 지원한다.
3.quicklisp을 설치한다. quick lisp은 common lisp의 package manager다. Library Manager로 부른다.
library를 가져오고 설치하는것은 다음을 참고 한다.
[[https://www.quicklisp.org/beta/#installation][참조]]
quicklisp을 설치할 때, 인증관련 문제가 생길 수 있다. 이때 다음~을 [[https://www.cs.dartmouth.edu/~sergey/cs59/lisp/sbcl-quicklisp-install-log.txt][참조]]한다.
quicklisp이란 폴더가 만들어지는데, 이 폴더를 emacs에서 참조한다. 나중에 system에 재설치시 참조해야 한다.
- slime-helper에 관해
  emacs에서 quicklisp을 사용하려면 helper의 도움이 있어야 한다. 그런데 이 helper는 sbcl에서 만든다.
sbcl=> (ql:quickload "quicklisp-slime-helper") 이렇게 하면
slime-helper.el이 만들어지고 이를 emacs에서 추가한다.
- emacs에서 slime실행(M-x slime)
:end:
#+begin_src emacs-lisp
    (use-package slime
    :init
    (load (expand-file-name "~/quicklisp/slime-helper.el"))
    (setq inferior-lisp-program "sbcl"))
#+end_src
** Prolog [Programming Language]
:설정:
1) swi-prolog를 설치한다.(brew install swi-prolog)
:end:
#+begin_src emacs-lisp

#+end_src
** Projectile

- 참조
[[https://projectile.mx/][Projectile]] 
- project를 관리하는 app, project가 위치할 곳을 정해두고 거기서 project를 생성해야 처리가 된다.
- projectile-rg
가장 많이 사용하는 grep인데, system에 ripgrep을 설치하고 사용한다.

#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p "~/MyWorld/Projects/Code")
      (setq projectile-project-search-path '("~/MyWorld/Projects/Code")))
    (setq projectile-switch-project-action #'projectile-dired))

  (use-package counsel-projectile
    :config (counsel-projectile-mode))

#+end_src
** Terminal 
***   terminal
vterm을 추천한다.
#+begin_src emacs-lisp
(use-package term
  :config
  (setq explicit-shell-file-name "zsh")
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

(use-package eterm-256color
  :hook (term-mode . eterm-256color-mode))

#+end_src
*** Vterm
- vterm은 emacs native terminal이라서 빠르다.
- vterm을 사용하기 위해선, system에 cmake가 설치되어 있어야 한다. (brew install cmake libtool)
#+begin_src emacs-lisp
(use-package vterm
  :commands vterm
  :config
  (setq vterm-max-scrollback 10000))
#+end_src
** Shell
eshell을 추천한다.
:설정:
osx system terminal에서 open -a 'Google Chrome'하면  terminal에서 chrome browser를 open할 수 있다. 보통은 alias를 써서 chrom,firefox로 호출한다. emacs의 eshell에서 chrome이나 firefox같은 외부 프로그램을  위와 같이 실행할 수 있다면 개발에 도움이 된다. 

[1] eshell에서 외부프로그램 실행

그런데  emacs의 eshell은 system의 shell과 path와 aliase가 동기화 되지 않기 때문에 직접 만들어주던가 system의 path와 alias를 가져오는 방식으로 한다.
- path: exec-path를 사용
- alias: eshell에서 alias chrome open -a "Google Chrome"를 입력하면 .emacs.d/eshell/alias에 파일로 alias가 기록된다. (ex: 현재 폴더 finder를 실행하기 위해선  alias f open .)
  물론 path도 addpath라는 명령어로 eshell에 적용할수 있다. 그러나 위의 path는 exec-path를 사용하기로 한다.
  path와 alias가 설정되면, eshell에서 chrome으로 chrome browser를  띄우거나, f를 눌러서 finder를 띄울 수 있다.

[2] M!(shell command)로 외부 프로그램 실행하기
path는 적용되나 alias는 적용되지 않는다. 그래서 open -a 'Google Chrome'과 같이 입력해야 한다. 이게 약간 불편하다. 
:end:
#+begin_src emacs-lisp
    (defun holy/configure-eshell ()
      (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)
      (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

      (setq eshell-history-size                    10000
             eshell-buffer-maximum-lines 10000
             eshell-hist-ignoredups t
             eshell-scroll-to-bottom-on-input t))

    (use-package eshell-git-prompt)

    (use-package eshell
      :hook (eshell-first-time-mode . holy/configure-eshell)
      :config
      (with-eval-after-load 'esh-opt
         (setq eshell-destroy-buffer-when-process-dies t)
         (setq eshell-visual-commands '("htop" "zsh" "vim" "less" "more")))
      (eshell-git-prompt-use-theme 'powerline))

     (use-package exec-path-from-shell)

#+end_src
** Magit
- 참조
[[https://magit.vc/][Magit]] 
- forge
forge는 github,gitlab과의 연동을 위해서 사용한다고 한다. issues라던지, pull request를 할수 있다. 자체적으로 db를 설치한후 github이나 gitlab에서 정보를 받아서 저장한다.
- magit-branch-read-upstream-first 'fallback
magit에서 branch를 만드는 명령어가 안된다. 되게 해주는 setting
#+begin_src emacs-lisp

  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge)

(setq magit-branch-read-upstream-first 'fallback)
#+end_src

** Rainbow Delimiters

- 참조
[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] 
parenthesis topology를 color별로 나타낸다.
show-paren-mode는 parenthesis를 쌍으로 check한다.
#+begin_src emacs-lisp

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  (show-paren-mode 1)
#+end_src

* File Management
- ^, dired-jump(C-x j)
상위폴더로 이동, dired-jump는 현재 buffer에서 dired mode로 전환한다.
- C-o (dired-display-file)
파일을 other window에서 open
- dired-listing-switch
listing을 sorting한다. directory 먼저 나오고 그다음 file
- dired-hide-detail( open parenthesis )
파일 이름만 나오게 한다.
- dired-toggle-marks
하나의 파일을 m을 눌러 mark한 후 t를 누르면 mark된 파일 빼놓고 모든 파일이 mark된다.
- dired-mark-files-regex
%키를 누르면 sub menu가 나온다. m(dired-mark-files-regex)을 선택하고 원하는 파일의 패턴을 입럭한다. 
예를 들면, .org$; 이것은 org로 끝나는 파일을 의미한다.
- *
sub menu가 보이고 조건에  맞는 파일을 mark한다.
- =[copy & rename & move]=
  - c 
    copy single file
  - C
    copy multiple marked file
  .R (rename & move)
   rename 할 이름을 입력한다.
   rename할 이름을 minibuffer에 입력할때, 원하는 폴더로 이동해서 enter를 치면 move가 된다. 

- =[ dred-dwim-target ]=
이 변수를 true로 setting하면 dwim을 사용할 수 있다. 예를 들어 dired buffer를 2개를 띄운 다음 copy를 하기 위해 C를 누르면 target의 위치가 열려진 direed buffer로 정해진다. target의 위치를 따로 정할 필요가 없다. 이런 것을 dwim이라고 한다. 

- =[zip,unzip]=
가장 유용한 기능중 하나. 파일을 선택하고 Z를 누르면 zip,unzip할 수 있다. 확장자는 tar.gz다.
만일 zip으로 압축하고 싶다면,
- dired-compress-files-alist의 값을 zip으로 하면 된다. 사용법은 describe-variable에서 살펴보면 된다.

- =[other useful,helpful]=
- shift-M
 file mode변경
- shift-t
=> 파일의 timestamp를 변경할 수 있다.
- shift-o
 파일의 owner를 변경
- shift-g
=>파일의 group을 변경
- shift-s
=> symbolic link를 만든다.

- =[all-the-icons-dired-mode]=
=> dired모드에 icon

- =[dired-open]=
=> dired mode에서 선택된 파일은 emacs내에서 처리한다. 외부 프로그램에서 처리하게 할 때 이 package를 설치하고 &를 누르면 외부 프로그램을 사용할 수 있다.
예를 들어, html=>browser, png=> adobe, mp3=>mpv

- dired-listing-switches
이것은 dired에서 sorting해서 보여주는 설정인데, mac에서는 ls란 utility가 전체 설치가 안되어 있어서 동작하지 않는다. 이것을 사용하기 위해선 brew install coreutils를 설치해야 agho라는 option을 처리할 수 있다. 또한 다른것도 처리해야 하는데, 나는 그냥 안쓰기로 했다.

- =[dired-maybe-insert-subdir]=
매우 유용한 명령어, i key와 binding되어 있는데, subfolder를 볼때 새 버퍼를 띄우지 않는다. 하나의 buffer에서 subdir을 계속 보여줄 수 있다. 매우 유용한 명령어다.
** Dired
#+begin_src emacs-lisp
  (use-package dired
  :ensure nil
  :commands (dired dired-jump)
  :bind (("C-x C-j" . dired-jump))
  ;; :custom ((dired-listing-switches "-agho --group-directories-first"))
  )

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  ;; (use-package dired-open
  ;;   :config
  ;;   (add-to-list 'dired-open-functions #'dired-open-xdg t)
  ;;   (setq dired-open-extensions '(("png" . "feh")
  ;;                                 ("mkv" . "mpv"))))

  (use-package dired-hide-dotfiles
     :hook (dired-mode . dired-hide-dotfiles-mode)
     :config 
     (define-key dired-mode-map "H" 'dired-hide-dotfiles-mode))
#+end_src
* Applications
** docker
#+begin_src emacs-lisp
  ;; (use-package docker
  ;;   :bind ("C-c d" . docker))
#+end_src
** email(Mu4e)
:LOGBOOK:
- Note taken on [2021-05-13 Thu 09:30] \\
  - [Gmail]과 imap동기화의 문제점
  Gmail은 mail을 folder로 관리하지 않는다. label로 관리한다. 오직 All Mails라는 하나의 폴더만 있는것 같다. mail이 들어오면 inbox라는 tag를 메일에 붙인다. 그리고 필요에 따라  important, starred,snoozed...같은  tag를 붙일 수 있다.  하나의 메일에는 여러개의 tag가 붙을 수 있는 것이다. 이것은  마치 하나의 메일이 여러개의 폴더에 있는 것과 같은 효과를 준다. 근데 이게 imap을 사용할 때 문제가 된다. imap은 폴더로 관리하고 각 메일은 한개의 folder에만 있기 때문이다. 그래서 gmail과 imap을 동기화하기란 쉽지 않다.
  
  - All Mail에 대해서(Archiving)
  다른 mail server들은 mail을 폴더별로 관리해서 들어오는 mail은 inbox에 넣는다. filtering해서 spam은 spam폴더에, inbox에서 버리는 메일은 trash폴더에, 메일을 작성하다가 그만두면 draft라는 폴더에, 메일을 보내면 sent 폴더에 넣는다. 그런데 gmail에는 다른곳에 없는 All Mails라는 폴더가 있다. 그리고 inbox, sent,draft...같은 것들은 그냥 label이다. 즉 메일이 중복해서 존재한다. inbox에 있는 mail은 All Mails라는 곳에도 있고, sent에 있는 mail도 All Mails, important,snooze,사용자가 만든 label에도 있는 것이다.
  
  - [imap과 Gmail]을 어떻게 동기화 할것인가?
  Gmail에서 email은 모두 label로 관리된다. 반면 imap은 폴더로 관리된다. Gmail에서는 하나의 email이 여러개의  label에 있을 수 있지만, imap은 하나의 folder에만 있게 된다. 이를 관리방법이 다른 이 두개를 어떻게 동기화 하고 사용할 것인가?
  1) [Gmail 기준으로 관리하자]- label을 폴더로 관리하자.
  즉 gmail의 label을 imap의 폴더로 mapping하는 것이다. gmail에서 메일을 작성하고, 보내고, 받고 할때 모든 mail은 label되서 관리된다. email을 보내면 sent라는 label,All mails에서 볼수 있다. important label도 붙였다면 important label에서도 볼 수 있다. 이것을 그대로 imap으로 가져오면 important 폴더, All mails폴더,sent라는 폴더에는 동일한 email이 있을 것이다. imap이 단지 보기만 한다면 이건 문제 없다. 근데 imap에서 mail을 작성해서 보낸다면, sent라는 폴더에만 email이 있을 것이다. 이것을 동기화 하면 gmail에서는 sent에만 있고, all mails에는 없는 현상이 발생한다. 이렇게 되면 gmail에서 보기 너무 힘들어버린다. 또한 imap에서는 중복된 email이 너무 많아진다.
  
  2) [imap 기준으로 관리하자] - All mails, trash,spam만을 가져오자.
  gmail에서 모든 mail은 3가지중에 하나다. spam이던가,trash이던가, all mails(archive)이던가... spam은 all mails에서 보이지 않는다. trash에서도 보이지 않는다. 이것을 imap에서 폴더로 만들어서 관리하는 것이다. imap과 동기화하면 gmail의 모든 mail이 imap에 오는것을 보장한다. 대신 gmail에서는 labeling으로 email을 관리하지 않을 것이다. imap에서 mail을 보낼경우, 보낸메일은 어디로 저장하는가? 선택할 수 있는건, All mails와 spam,trash인데, All mails로 할 수 밖에 없다. 그런데 이렇게 하면 gmail에서 내가 보낸 메일을 확인할때 all mails로 봐야 하는데, 이게 보낸 메일인지 받은메일인지 구분할 수가 없다.
  
  3) [Imap과 Gmail을 조합해서 관리하자]
  동기화할 폴더를 All Mails, Sent,draft, trash, spam으로 정하자. Gmail에선 Sent,draft 메일들은 모두 All mails에 있다. 그럼 imap으로 다운하면 중복되는 email이 있을 것이다. 하지만 imap을 사용할때는 편리하다. 받은 메일은 All mails에서 확인하면 되고, 메일을 작성하다가 멈췄을때는 draft로 보내고 보낸 메일은 sent로 보내면 imap과 gmail에서 공통적으로 사용하는 폴더와 label이기 때문에 문제 될 것이 없다. 단점은 2가지 정도 된다. 첫 번째로 imap에서 mail이 중복되는 문제, 두 번째로 imap에서 메일을 보내면 sent에 저장된다. 그리고 sent에 있던건 gmail의 sent에 동기화 된다. 따라서 gmail에서 보면 All mails에는 보낸 메일이 보이지 않는다는 것이다. 반면 gmail에서 mail을 보내면 sent와 All mails에 있고 동기화 하면 imap에서는 All mails와 sent에 둘다 있게 되는 것이다. imap으로 볼때 어떤 mail은 sent에도 있고 All mails에도 있고, 어떤건 sent에만 있는것을  확인할 수 있다. 또한 gmail에서 볼때도 어떤 mail은 sent에도 있고 All mails에도 있고, 어떤건 sent에만 있는것을 확인할 수 있다. 하지만, 이것은 감내해야 할듯 하다.
- Note taken on [2021-05-12 Wed 02:31] \\
  다음과 같은 에러가 발생할 수 있다.
  IMAP command 'AUTHENTICATE PLAIN <authdata>' returned an error: NO [AUTHENTICATIONFAILED] Invalid credentials (Failure)
  Authentication Error는 ID와 PW가 제대로 기술이 안되어 있을경우, 혹은 gmail server에서 web browser가 아닌 3rd party app에서 접근하는것을 막았을경우에 발생한다. 이 경우는 gmail에서 mail이 전송된다. 메일에 있는 link를 누르면, less secure app access를 turn on시킬수 있다. 이렇게 하면 접근이된다.
- Note taken on [2021-05-11 Tue 19:52] \\
  RSA통신: public key와 private key를 사용해서 서로간의 통신을 하기 위해서는 한쪽이 public key를 보내야 한다. 그러기 위해서 인증서에 public key를 넣어서 보낸다.  이런 통신을 이용하는 경우는 대표적으로 gmail과 같은 mail provider가 해당한다. 
  gmail 통신방법:  client와 gmail은 ssl을 사용한 imap이나 pop을 사용해서  mail을 down받거나 보내는 작업을 한다. server에 해당하는 gmail이 public key와 private key를 만든다. public key를 이용해서 인증서도 만든다. client가 gmail에 연결을 시도해서 인증서를 다운받고 받은  그 다음 부터 gmail의 public key를 사용해서 통신한다.
  
  gmail의 인증서를 얻는 방법:
  $ mkdir ~/.cert
  $ openssl s_client -connect some.imap.server:port -showcerts 2>&1 < /dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sed -ne '1,/-END CERTIFICATE-/p' > ~/.cert/some.imap.server.pem

    openssl s_client -crlf -connect imap.gmail.com:993 -showcerts 2>&1 < /dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sed -ne '1,/-END CERTIFICATE-/p' > ~/.cert/imap.gmail.crt
    
  github 통신방법: 사용자가 public key와 private key를 만든다. public key를 github에 넣어두고 통신한다.
  
- Note taken on [2021-05-11 Tue 18:40] \\
  SSL: SSL은 secure socket layer다. 예전에는 tcp+ip를 사용하는 socket으로 programming해서 통신을 했다. secure socket은 이 tcp+ip에 보안요소를 곁들인 계층 혹은 socket으로 보면 된다. 흔히 우리는 domain 주소를 실제 주소로 비유하고, dns서버는 주소를 입력하면 전화번호를 알려주는 기능을 하고, tcp+ip에서는 전화번호로 통신한다고 말한다.  ip주소가 server의 전화번호이고, port가 내선번호라고 한다. 이렇게 전화번호와 내선번호로 통화를 하면 도청의 위험이 있어서 전화내용을 암호화할 필요가 생겼다. 그래서 생긴게 SSL이다. SSL은 전화걸기 전에 우선 상대방의 공개키를 내가 알고 있던지 아니면, 나의 공개키를 상대방한테 줘야 한다. 그래서 받은 공개키를 통해서 암호화해서 통신을 한다.
  
  인증서: 공개키를 상대방한테 보낼때 단지 public key만 보내면 안된다. 보내는 사람이 public key를 보냈다고 해서 무턱대고 중요한 정보를 받은 public key로 암호화해서 보내면 안된다. 보낸사람이 확실한지 확인해야 한다. 해커가 보낸사람을 가장해서 public key를 보내고 그 public key를 사용해서 통신을 한다면, 해킹당하는 것이기 때문이다.   예를들어, 국세청에서 저희하고 통신할려면 저희 공개키를 보낼테니 그걸로 암호화해서 보내세요.납세자에게 보냈다고 하자. 납세자는 국세청인줄 믿고 암호화해서 서로 메일이나 chat을 하면 안된다. 해커가 자신의 공개키를 국세청의 공개키라고 속일수 있기 때문이다. 그래서 인증서는 공개키가 국세청의 공개키가 맞다는 것을 보장해준다.
- Note taken on [2021-05-11 Tue 17:03] \\
  GPG: RSA방식의 암호화를 사용하게 해주는 tool이다. 2개의 key를 만든다. 공개키와 비밀키인데,  단순하게 열쇠와 자물쇠 2개를 만든다고 보면 된다. 통신하게 될 2개의 당사자들은 비밀키와 공개키를 이용해서 통신한다고 보면 된다. 옛날의 암호화 방식이나, password방식은 일종의 server가 password파일 목록을 가지고 있고 사용자가 입력한 password가 맞는지 안맞는지 서버에서 판단했다. 이것은 현관문의 door key와 비슷하다. 출입하는 사람은 비밀번호를 입력하고 문에는 비밀번호 목록을 가지고 있는 방식이다. 반면에 RSA는 개개인이 열쇠와 자물쇠를 모두 만들어서 자물쇠를 주는 방식이다. 그런데 둘다 key라고 부르는 이유는 둘다 암호화 복호화에 사용되는 key로 동작하기 때문이다. private key로 암호화하면 public key로 해독하고 public key로 암호화하면 private key로 복호화 한다.
:END:
:IMAP설정:
   - [X] isync 설치
             local에서 gmail과 sync를 할 프로그램을 설치한다. brew install isync
             
   - [X] ~/.mbsyncrc를 설정한다. 여길 [[file:~/.mbsyncrc][참조]]
           - Mail폴더를 만든다. subFolder에 Gmail과 Fastmail을 만든다. 이것은 imap에서 가져올 메일을 저장하는 곳이다. PATH와 INBOX설정에 기술한다.
          - 여기서 passCmd와 certificateFile은 설명이 필요하다.
          - [passCmd]: mail server에 login하기 위해선 id,pw가 필요하다. id는 위 항목중 user를 의미하고, pw는 pass를 사용했다.하지만, 지금은 pass는 보안문제로 사용되지 않는다. pass는 password를 직접 mbsyncrc파일에 기술하는 것이다. 반면  직접기록하는 대신에 특정파일에 적어놓고 이를 cat과 같은 명령어로 읽어들이거나 gpg를 사용한다. 나는 cat을 사용했고 해당 password는 gmail은 직접 파일에 기술했고, fast mail은 아래 설정에서 app password를 받아서 사용했다.
            ex) "cat ~/.oh-no-insecure-password"
            ex) gpg --quiet --for-your-eyes-only --no-tty --decrypt ~/.passwords/gmail.gpg
          - 인증서는 logbook에 적었는데, openssl을 통해서 gmail에 접속하면 gmail의 public key가 담긴 인증서를 얻을 수 있다. 얻은 인증서를 저장한 후 적용하면

 - [X] imap server를 설정한다. 
         google gmail과 fastmail을 web에서 접속한다. 접속후 설정화면으로 간다.
        - [gmail]: [[https://support.google.com/mail/answer/7126229?hl=en][설정법]], two-pass인증을 사용한다면, app password를 받아야 한다.아니면 less secure app으로 접속가능하게 해야 한다. [[https://myaccount.google.com/lesssecureapps?pli=1&rapt=AEjHL4NfiM5-El5bbUyLjtgLtJR3Q8iaaB1U3ZOSHERUwRyureo_rGEIPZbph5C8sgVJIyt4Ag3uL8ujJdkfLEfc9Tc93oKGlw][참조]]
        - [fastmail]: settings->password->app password

- [X] 설정이 끝났으면 동기화 테스트를 한다.(mbsync -a)
          - two pass인증 에러는 Application-specific password required란 에러나 나온다.
          - ~/Mails/폴더에 가서 [Gmail]Sent Mail, [Gmail]Drafts...와 같은 폴더가 있는지 확인해 본다.
          - Error: SASL(-7): invalid parameter supplied: Parameter Error in /BuildRoot/Library/Caches/com.apple.xbs/Sources/passwordserver_saslplugins/passwordserver_saslplugins-192.30.1/plain_clienttoken.c near line 195 가 나서 AuthMechs PLAIN을 설정에 추가했다.
          - Error: channel fastmail: far side box Inbox cannot be opened.
          - Maildir warning: ignoring INBOX in /Users/holy/Mail/Fastmail/
           => Inbox관련 warning과 error는 mbsyncrc의 Inbox ~/Mail/Fastmail/Inbox/ 에서  ~/Mail/Fastmail/Inbox 로 바꿔줬더니 정상동작한다.

- [X] mu를 설치한다. (brew install mu)
  - mu를 system에 설치하면, mu4e도 설치가 된다. emacs에서 mu4e를 load할때는 아래 path를 사용해서 load한다.
    path: /usr/local/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e
    
- [X] mu init(예전 mu index) 실행한다. 저장된 mail에 indexing을 한다고 보면 된다. index tree를 만들어 검색을 빠르게 하는 것이다.
  (mu init --maildir=~/Mail --my-address=holy.frege@gmail.com --mail-address=holy_frege@fastmail.com)    

- [X] emacs에서 mu4e를 설정한다. 아래 코드 부분이다. mu를 설치할때 mu4e elisp들이 설치되는데 그경로(load-path)를 기술한다.
  - 설치할 때 mu4e-meta.el이 newer than oldfile이라고 나오면 해당 load-path로가서 mu4e-meta.elc를 지우고 다시 byte compile한다.
  - 10분마다 자동 sync하기로 했다.
  - mu4e [[https://www.djcbsoftware.nl/code/mu/mu4e/index.html][공식문서]]
    
- [X] mu4e 실행 (M-x mu4e)
  - j o 를 누르고 maildir에서 [Gmail]/Sent Mail, [Gmail]Drafts, [Gmail]Trash,[Grmail]/All mails 이외의 것이 있나 확인한다. 왜냐면 우리는 imap에서 이 4개의 폴더로 email을 관리하고 이 폴더들이 gmail과 동기화해서 web에서 gmail을 볼때 보여야 하기 때문이다.

  - C-c C-u: mbsync -a를 실행해서 update여부를 확인한다. mu4e main화면에 u를 눌러도 된다.
- [X] Mu4e context(account) 설정

:END:
:SMTP설정:
- 설정에 대한 story
  - [X] SMTP server 설정
    - mu4e에서 mail계정은 context로 불리기도 한다. 각각의 계정마다 아래 smtp server 설정을 해준다. gmail과 fastmail에서 snmp정보를 찾을 수 있다. googling해서 찾아서 기입하면 된다.
    - smtpmail-smtp-server - The host where we connect to send mail
    - smtpmail-smtp-service - The port number of the SMTP service (defaults to 25)
    - smtpmail-stream-type - Determines whether SSL or TLS should be used when connecting

- [X] Mail 작성법
  - C(compose)를 누른다.
  - from, to , subject를 입력한다. from, to는 <tab>으로 list중 하나를 선정 가능하다.
  - C-c C-c : send the message
  - C-c C-k : discard the message
  - C-c C-d : save message in Draft folder.

- [X] mail 보내기 password문제.
  - mail을 보내기 위해 C-c C-c를 누르면 id와 pw를 물어본다. 이것을 물어보지 않고 자동화 할 수 있는 방법이 있다.
  - ~/.authinfo라는 파일을 만들고 pw를 저장한다음 (setq message-send-mail-function 'stmpmail-send-it)을 설정하면, smtpmail-send-it이 호출될때, auth-source라는 library를 사용한다. 이  library는 .authinfo라는 파일에서 정보를 읽어서 접속한 server에 입력한다. auth-sources는 authinfo외에도  ~/.authinfo.gpg, ~/.netrc라는 파일이 있으면 자동으로 읽는다.
    => (setq message-send-mail-function 'stmpmail-send-it)을 설정하고 .authinfo에 id와 pw만 작성하면 mail을 작성해서 보낼때 id와 pw를 입력하지 않아도 되지만, 보안에 문제가 있기 때문에 .authinfo.gpg라는 파일에 id와 pw를 작성하면 자동으로 gpg encrypt와 decrypt가 실행된다.

    즉 정리하면 (setq message...)와 authinfo.gpg에 id와 pw를 작성하면, mail을 작성하고 C-c  C-c를 눌러서 전송하면, 내부적으로 gpg라이브러리가 .authinfo.gpg를 decrypt한후 id와 pw을 읽어서 해당 smtp에 login하고 메시지를 전송하게 된다. 이 과정을 다시 설명해 보겠다.

           *GPG 사용법*
           . [1] authinfo에 다음을 기술한다.
           machine smtp.fastmail.com login holy.frege@gmail.com password mypassword port 465
           machine smtp.fastmail.com login holy_frege@fastmail.com password mypassword port 465
           => fastmail은 app password를 기입하고, gmail은 2pass인증을 하지 않기 때문에 직접 pw를 입력했다.
       
           . [2] authinfo를 encrypt 하기위해서 key를 만든다. key를 만들때 아래 질문을 참고한다.
              gpg --full-generate-key 

             - What kind of key do you want? (1) RSA and RSA (default)
             - What keysize do you want? 4096
             - How long should the key be valid? 0 (Key does not expire)
             - Enter your name
             - Enter your e-mail address
             - Enter a comment for the key (not necessary, but can be used to identify it)
             - If everything looks good, press O for “Okay”
             - You will now be prompted for a passphrase. This is like a password for your encryption key, it should be secure and memorable!
             - After entering the password, it will generate the new key. Move the mouse around or press keyboard keys to help generate entropy.

              gpg --list-keys로 key를 확인한다.
        
           - [3] gpg encrypt에 관해
              .authinfo.gpg라는 파일을 만들고 .authinfo의 내용을 복사한다. 그리고 저장 하려고 하면 자연스럽게 encrypt menu가 뜨면서 gpg로 encrypt되어 저장된다. 이렇게 되는 이유는 gpg확장자를 갖는 파일은 무조건 gpg로 encrypt하기때문이다. 따라서 별도의 작업이 필요치는 않다. 그냥 저장하면 menu가 뜨고 menu에서 원하는 key를 선택하고 ok버튼을 누르면 encrypt되기 때문이다.

            - [4] 메일 보내기
              여기까지 하고 mu4e로 들어가서 메일을 작성한 후에 C-c C-c로 메일을 보낸다.
              error: no secret key가 없다면서 timeout이 걸릴 수 있다.  [[https://emacs.stackexchange.com/questions/27841/unable-to-decrypt-gpg-file-using-emacs-but-command-line-gpg-works][참조]]에 나와 있듯이 (setf epa-pinentry-mode 'loopback)을 .emacs.org에 추가시킨다. 이러면 timeout이 안걸리고 .authinfo.gpg를 decrypt해서 id,pw를 꺼내올 수 있다.

:end: 
#+begin_src emacs-lisp
    (use-package mu4e			
      :ensure nil
      ;; :defer 20
      ;; :load-path "/usr/local/share/emacs/site-lisp/mu/mu4e/"
      ;; brew를 사용한 경우 아래에 있다.
      :load-path "/usr/local/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e/"
      ;; :defer 20 ; Wait until 20 seconds after startup
      :config
      (require 'mu4e-org)


      (setq mail-user-agent 'mu4e-user-agent)
      ;; This is set to 't' to avoid mail syncing issues when using mbsync
      (setq mu4e-change-filenames-when-moving t)
      ;; Refresh mail using isync every 10 minutes
      (setq mu4e-update-interval (* 10 60))
      (setq mu4e-get-mail-command "mbsync -a")
      (setq mu4e-maildir "~/Mail")

      (setq message-send-mail-function 'smtpmail-send-it)
      (setf epa-pinentry-mode 'loopback)
      ;; mu4e sending message settings(smtp)
      (setq mu4e-contexts
         (list
         ;; Work account(gmail-holy.frege)
         (make-mu4e-context
          :name "public_mail(gmail)"
          :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/Gmail" (mu4e-message-field msg :maildir))))
          :vars '((user-mail-address . "holy.frege@gmail.com")
                  (user-full-name    . "Holy Frege work_mail")
                  (smtpmail-smtp-server  . "smtp.gmail.com")
                  (smtpmail-smtp-service . 465)
                  (smtpmail-stream-type  . ssl)
                  (mu4e-compose-signature .
                  (concat 
                       "Holy Frege \n\n"
                       "seize the time\n"
                       "test signature\n"))
                  (mu4e-drafts-folder  . "/Gmail/[Gmail]/Drafts")
                  (mu4e-sent-folder  . "/Gmail/[Gmail]/Sent Mail")
                  (mu4e-refile-folder  . "/Gmail/[Gmail]/All Mail")
                  (mu4e-trash-folder  . "/Gmail/[Gmail]/Trash")))

         ;; Personal account(fastmail)
         (make-mu4e-context
          :name "Private_mail(fastmail)"
          :match-func
            (lambda (msg)
              (when msg
                (string-prefix-p "/Fastmail" (mu4e-message-field msg :maildir))))
          :vars '((user-mail-address . "holy_frege@fastmail.com")
                  (user-full-name    . "Holy Frege Personal_mail")
                  (smtpmail-smtp-server  . "smtp.fastmail.com")
                  (smtpmail-smtp-service . 465)
                  (smtpmail-stream-type  . ssl)
                  (mu4e-compose-signature .
                  (concat 
                       "Holy Frege \n\n"
                       "grap the time\n"
                       "test2 signature\n"))
                  (mu4e-drafts-folder  . "/Fastmail/Drafts")
                  (mu4e-sent-folder  . "/Fastmail/Sent")
                  (mu4e-spam-folder  . "/Fastmail/Spam")
                  (mu4e-refile-folder  . "/Fastmail/Archive")
                  (mu4e-trash-folder  . "/Fastmail/Trash")))))
      ;; %a: 메일의 title이다.
      ;; %i: mail의 특정 text영역을 block한후 paste한다. 
     ;; (setq org-capture-templates
     ;;   `(("m" "Email Workflow")
     ;;     ("mf" "Follow Up" entry (file+olp "~/org/Mail.org" "Follow Up")
     ;;           "* TODO Follow up with %:fromname on %a\nSCHEDULED:%t\n\n %i" :immediate-finish t)
     ;;     ("mr" "Read Later" entry (file+olp "~/org/Mail.org" "Read Later")
     ;;           "* TODO Read %:subject\nSCHEDULED:%t\n%a\n\n %i" :immediate-finish t)
     ;;   ))
  ;; quick action
     (defun holy/capture-mail-follow-up (msg)
        (interactive)
        (call-interactively 'org-store-link)
        (org-capture nil "mf"))

     (defun holy/capture-mail-read-later (msg)
        (interactive)
        (call-interactively 'org-store-link)
        (org-capture nil "mr"))
        ;; Add custom actions for our capture templates
     (add-to-list 'mu4e-headers-actions
         '("follow up" . holy/capture-mail-follow-up) t)
     (add-to-list 'mu4e-view-actions
         '("follow up" . holy/capture-mail-follow-up) t)
     (add-to-list 'mu4e-headers-actions
         '("read later" . holy/capture-mail-read-later) t)
     (add-to-list 'mu4e-view-actions
         '("read later" . holy/capture-mail-read-later) t)

     (setq mu4e-maildir-shortcuts
      '((:maildir "/Gmail/Inbox"    :key ?i)
        (:maildir "/Gmail/[Gmail]/Sent Mail" :key ?s)
        (:maildir "/Gmail/[Gmail]/Trash"     :key ?t)
        (:maildir "/Gmail/[Gmail]/Drafts"    :key ?d)
        (:maildir "/Gmail/[Gmail]/All Mail"  :key ?a))))
        ;; run mu4e in the background to sync mail periodically
      ;; (mu4e t)  
      ;; (setq user-mail-address "holy.frege@gmail.com")
      ;; (setq smtpmail-default-smtp-server "smtp.gmail.com")
      ;; (setq smtpmail-smtp-server "smtp.gmail.com")
      ;; (setq smtpmail-smtp-service 587))


#+end_src

#+begin_src emacs-lisp
    (use-package org-mime
      :ensure t
      :config
      (setq org-mime-export-options '(:section-numbers nil
                                      :with-author nil
                                      :with-toc nil))
      ;; (add-hook 'message-send-hook 'org-mime-htmlize)
      ;; (add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)
      (add-hook 'message-send-hook 'org-mime-htmlize)
      (add-hook 'org-mime-html-hook
         (lambda ()
            (org-mime-change-element-style
             "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                           "#E6E1DC" "#232323"))))
    )

  (add-hook 'message-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-e" 'org-mime-edit-mail-in-org-mode)))

  (add-hook 'message-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-h" 'org-mime-htmlize)))

  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-o" 'org-mime-org-buffer-htmlize)))

  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key "\C-c\M-s" 'org-mime-org-subtree-htmlize)))
#+end_src
:org_with_email:
   - [X] org mode로 편지 쓰기 org mode로 편지를 쓰거나, image를
     첨부하거나, 이미 있는 org file을 메일로 보낸다거나 할때
     org-mime이라는 package를 사용한다. [[https://github.com/org-mime/org-mime][참조 ]]email의 body는 plain
     text이다. 이것을 html포맷으로 바꿀 수 있다. org모드로 작성하고
     html포맷으로 바꾸는 것이다. 이렇게 되면 link를 사용할 수 있고,
     image,code block, formatted text를 사용할 수 있다는 장점이 있다.
     - Formatted text (bold, italic, etc)
   - Headings and subheadings
     - Links
     - Code blocks
     - Images (that get attached correctly)
     … anything that org-mode can convert to HTML

1) mu4e에서 org 문서 작성후 htmlize해서 보내기
   - mu4e Compose mail에서 org로 글 작성 -> org-mime-htmlize해서 보낸다.
   - mu4e Compose mail에서 editer buffer
     (org-mime-edit-mail-in-org-mode) 를 실행하면 org buffer가
     생긴다. 더많은 org 기능을 사용할 수 있다. 다 작성후에 C-c C-c를
     누르고 org-mime-htmlize해서 보낸다. 단축키를 C-c M-e로
     설정했다. 작성한 후 org-mime-htmlize(C-c C-h)를 실행후 보낸다.

2) org문서를 mail로 보내기
   - org 문서에서 M-x org-mime org-buffer-htmlize(C-c M-o) 하면
     compose창이 뜨고 바로 email로 전송할 수 있게 된다.

3) org문서의 특정 헤더를 mail로 보내기 
   - org mode의 heading은 그 자체가 하나의 subtree다. org buffer에서
     하나의 heading에 cursor를 두고 M-x
     org-mime-org-subtree-htmlize(C-c M-s)를 하면 Mu4e의 Compose가
     뜨고 해당 헤더를 title로 하는 메일을 보낼 수 있다.

4) org문서를 html로 바꿀때 css적용
   - org-mime-change-element-style을 통해서 css속성을 적용할 수
     있다. code는 pre 태그로 변환되는데, 이때 pre의 속성을 변경하면
     된다.
   
5) org문서나, mu4e에서 org로 작성해서 보낼때, 이상한점.
   - section이 보인다.
   - toc이 보인다.
   - author가 보인다.
=> 만일 안보이게 하렴녀 org-mime-export-option을 추가한다.

6) 매번 mu4e에서 org-mime-htmlize를 해줘야하는 문제점.
mu4e에서 작성하는 text는 plain text다. org로 작성해도 plain
text다. 다양한 기능을 사용하는 html로 바꾸기 위해서는 매번 mail을
작성하고 org-mime-htmlize를 해줘야한다. 이것을 자동으로 할수도
있다. 하지만, 가끔은 plain text를 필요로 하는 경우가 있기 때문에
경고창만 보내고 수동으로 org-mime-htmlize를 하는 방식을 추천한다.
(add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)
자동으로 무조건 적용하려면 (add-hook 'message-send-hook
'org-mime-htmlize)를 해주면 된다.

:end:
:org-capture_mail일정관리:
[[https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-Mail-05.org][참조]] mu4e를 사용하는 주된 이유 중 하나는 mail을 org일정관리에 사용할
수 있다는 점이다. web에서 mail을 보는 대신 emacs라는 편집기에서 mail을
볼수 있고, org파일을 손쉽게 mail로 보낼수 있는것도 mu4e를 사용하는
주된 이유이긴 하나, 내 생각에 메일중에 중요한것은 org파일로 이동
시켜서 일정관리에 사용될수 있다는 점 같다. 그것이 org-capture다.

- 수행 시나리오 Mu4e를 실행한다. 메일 목록이 나와 있는 header view로
  간다. cursor를 원하는 메일에 올려놓는다. M-x org-capture를
  한다. menu에서 m을 선택하면, read later, Follow up을 선택한다.org
  Edit buffer view가 보인다. 글을 작성하고 C-c C-c를 하면 헤당
  header아래에 저장된다. 저장될때, mail의 link도 포함되어 있다. link를
  open하면 mu4e가 다시 실행된다.  immediate-finish를 설정해서 더
  빠르게 작업할 수 있다. 즉 mail의 header view에서 cursor를 특정메일에
  놓고 org-capture를 하면 menu에서 m을 선택하고 어떤 항목에 넣을지를
  선택만 하면 된다. org edit buffer를 띄어서 특정 내용을 적을 필요가
  없다. 왜냐면 어차피 처리해야할 메일을 todo리스트로 정해서 올려만
  두고 실제일은 나중에 할것이기 때문이다.

  그런데 이것보다 더 빠르게 일을 처리할 수 있다. quick action을
  사용하는 것이다.  quick action은 mail의 제목에 커서를 두고 M-x
  org-capture를 입력하고 거기서 또 m을 누르고 r이나 f를 다시 누를
  필요가 없다. mail 제목에 커서만 둔채로 a(action)을 누른다. 거기서
  f,r을 눌러서 follow up, read later항목에 메일을 이동 시킬 수 있다.
  
- 설정
1) mail이 저장될 org파일 설정: Org/Mail.org에 저장하기로
   함. Org파일에는 2개의 header를 둔다. Read Later와 Follow
   up이다. org-capture-template설정에 해당 header아래에 capture한
   todo를 둘 것이다. 이제 mail을 보고, 나중에 읽고 해야 할것에는 Read
   Later헤더아래에, Follow up해야 할것은 Follow 헤더 아래에 저장될
   것이다.

 2) 나머지 설정 참고

- org capture %i
org-capture에서 %i를 넣으면 mu4e 헤더뷰에서 메일을 읽고 특정 문장을 block으로 지정한후 org-capture를 하면 해당 block이 todo list에 들어간다.

- 여러가지 option
%:subject
%:from
%:fromname
%:to,%:toname
%:date 

- schedule과 deadline
schedule은 to do time, deadline은 to be done time이다. 스케쥴은 시작일이라고 보면 된다. project가 6월3에 스케쥴되었다는건 그때 시작한다는 뜻이다. 생일축하 파티가 6월 9일이면 그 때 시작한다는 것이다. 반드시 deadline이 있는 건 아니다. project나 task에 따라 어떤 것들은 schedule만 있고, 어떤 것은 deadline만 있고, 또 다른 어떤 것은 schedule과 deadline이 같이 있다.
1) schedule: %t
2) deadline: org-read-date란 함수를 사용해서 자동으로 +2일에 끝나게 설정할 수 있다.

- agenda file에 추가
org/mail.org를 agenda file에 추가해야만 agenda로 관리 할 수 있다.

- quick action
mu4e에서 mail을 읽고 이것을 해야할일(todo)라고 판단하면 org-capture를 실행해서 org/mails.org의 todo list로 넘기는 작업을 했었는데, header view(mail list)에서 간단히 제목만 보고 to do list로 넘길수 있다. 메일을 읽지않고도 메일 제목만 보고 해야 할일로 넘길 수 있다는 것이다. 그런데 보통의 처리과정은 다음과 같다. 오늘 메일을 다 읽는다. 그리고 header view에서 처리한다. 이렇게 header view에서 처리하기 위해서는 immedietly finish를 세팅해야 한다.
 :end:
** org-alert
#+begin_src emacs-lisp
  ;; (use-package alert
  ;;   :ensure t)
  ;; (use-package org-alert
  ;; :custom (alert-default-style 'notifications)
  ;; :config
  ;; (setq org-alert-interval 300
  ;;       org-alert-notification-title "org alert reminder!")
  ;; (org-alert-enable))
#+end_src
** org presentation
#+begin_src emacs-lisp
;(use-package org-tree-slide
;  :custom
;  (org-image-actual-width nil))

#+end_src
** readtheorg
** reveal.js

** lorem ipsum
- lorem ipsum은 의미없는 문자열을 만들어낸다.
#+begin_src emacs-lisp
  ;; (use-package lorem-ipsum
  ;; :config
  ;; (lorem-ipsum-use-default-bindings))
#+end_src
** yasnippet
- yasnippet은 특정 단어를  template과 replace할 수 있다. 특정 단어를 tab을 누르면 이미 저장된 template으로 대치된다.
#+begin_src emacs-lisp
  (use-package yasnippet
    :init
    (yas-global-mode 1)
    ;; (add-to-list 'yas-snippet-dirs "~/Dropbox/WorkSpace/emacs/snippets")
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    :bind
    ("C-c s" . yas-insert-snippet)
    ("C-c n" . yas-new-snippet)
    ("C-c v" . yas-visit-snippet-file))
#+end_src
** mobileorg
- mobileorg는 protocol이다. server로 dropbox를 사용한다.
  capture한 내용은 server의 mobile.org에 저장된다.
#+BEGIN_SRC emacs-lisp 
;; Set to the location of your Org files on your local system
(setq org-directory "~/org")
;; Set to the name of the file where new notes will be stored
(setq org-mobile-inbox-for-pull "~/org/flagged.org")
;; Set to <your Dropbox root directory>/MobileOrg.
(setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
#+END_SRC

